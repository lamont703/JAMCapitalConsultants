<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>JAM Chat Module</title>
    <!-- Add jsPDF library for PDF generation -->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/jspdf/2.5.1/jspdf.umd.min.js"></script>
    <style>
        /* Chat Container Styles */
        .Bot-chat-container {
            display: flex;
            flex-direction: column;
            height: 100%;
            padding: 20px;
        }

        .Bot-chat-messages {
            flex: 1;
            overflow-y: auto;
            margin-bottom: 20px;
            padding: 10px;
            background: #f8f9fa;
            border-radius: 12px;
        }

        /* Removed chat input interface CSS - no longer needed for button-only interface */

        /* Message Styles */
        .Bot-message {
            margin-bottom: 15px;
            display: flex;
            align-items: flex-start;
            gap: 10px;
        }

        .Bot-message.user {
            flex-direction: row-reverse;
        }

        .Bot-message-content {
            max-width: 70%;
            padding: 12px 16px;
            border-radius: 18px;
            word-wrap: break-word;
            line-height: 1.4;
        }

        .Bot-message.bot .Bot-message-content {
            background: white;
            color: #333;
            border: 1px solid #e9ecef;
        }

        .Bot-message.user .Bot-message-content {
            background: #09ccfc;
            color: white;
        }

        .Bot-message-avatar {
            width: 32px;
            height: 32px;
            border-radius: 50%;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 16px;
            flex-shrink: 0;
        }

        .Bot-message.bot .Bot-message-avatar {
            background: #09ccfc;
            color: white;
        }

        .Bot-message.user .Bot-message-avatar {
            background: #6c757d;
            color: white;
        }

        /* Button Styles */
        .Bot-message-buttons {
            display: flex;
            flex-wrap: wrap;
            gap: 8px;
            margin-top: 10px;
        }

        .Bot-chat-button {
            background: #007bff;
            color: white;
            border: none;
            padding: 8px 16px;
            border-radius: 20px;
            cursor: pointer;
            font-size: 14px;
            transition: all 0.2s ease;
        }

        .Bot-chat-button:hover {
            background: #0056b3;
            transform: translateY(-1px);
        }

        /* Typing Indicator */
        .Bot-typing-indicator {
            display: flex;
            align-items: center;
            gap: 10px;
            padding: 12px 16px;
            background: white;
            border: 1px solid #e9ecef;
            border-radius: 18px;
            max-width: 70%;
        }

        .Bot-typing-dots {
            display: flex;
            gap: 4px;
        }

        .Bot-typing-dot {
            width: 8px;
            height: 8px;
            border-radius: 50%;
            background: #09ccfc;
            animation: typing 1.4s infinite ease-in-out;
        }

        .Bot-typing-dot:nth-child(1) {
            animation-delay: -0.32s;
        }

        .Bot-typing-dot:nth-child(2) {
            animation-delay: -0.16s;
        }

        @keyframes typing {

            0%,
            80%,
            100% {
                transform: scale(0.8);
                opacity: 0.5;
            }

            40% {
                transform: scale(1);
                opacity: 1;
            }
        }

        /* Loading Styles */
        .Bot-loading {
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            padding: 40px;
            text-align: center;
        }

        .Bot-spinner {
            width: 40px;
            height: 40px;
            border: 4px solid #f3f3f3;
            border-top: 4px solid #09ccfc;
            border-radius: 50%;
            animation: spin 1s linear infinite;
            margin-bottom: 20px;
        }

        @keyframes spin {
            0% {
                transform: rotate(0deg);
            }

            100% {
                transform: rotate(360deg);
            }
        }
    </style>
</head>

<body>
    <script>
        // ChatModule - Properly structured like CreditReportUploaderModule
        const ChatModule = (function () {
            'use strict';

            // Private variables
            let messages = [];
            let currentAnalysisData = null;
            let parentModule = null;
            let typingIndicator = null;
            let isInitialized = false;

            // NEW: Conversation state management
            let conversationState = {
                phase: 'overview', // overview, category, item_review, letter_generation
                currentCategory: null,
                currentItemIndex: 0,
                selectedItems: [],
                skippedItems: [],
                completedCategories: [],
                userChoices: {},
                groupedItems: null,
                categoryOrder: ['high_impact', 'medium_impact', 'low_impact']
            };

            // Private helper functions
            function debugLog(functionName, status, data = {}) {
                console.log(`[ChatModule] ${functionName} - ${status}`, data);
            }

            function formatMessageContent(content) {
                if (!content) return '';
                content = content.replace(
                    /(https?:\/\/[^\s]+)/g,
                    '<a href="$1" target="_blank" rel="noopener noreferrer">$1</a>'
                );
                content = content.replace(/\n/g, '<br>');
                return content;
            }

            function formatSize(bytes) {
                if (bytes < 1024) return bytes + ' bytes';
                else if (bytes < 1048576) return (bytes / 1024).toFixed(1) + ' KB';
                else return (bytes / 1048576).toFixed(1) + ' MB';
            }

            function formatCategoryName(category) {
                const categoryMap = {
                    'personal_info': 'Personal Information',
                    'account_status': 'Account Status',
                    'payment_history': 'Payment History',
                    'duplicates': 'Duplicate Accounts',
                    'inquiries': 'Credit Inquiries',
                    'public_records': 'Public Records',
                    'collections': 'Collections',
                    'charge_offs': 'Charge-offs',
                    'late_payments': 'Late Payments',
                    'high_balances': 'High Balances',
                    'other': 'Other Issues'
                };
                return categoryMap[category] || category.replace(/_/g, ' ').replace(/\b\w/g, l => l.toUpperCase());
            }

            // NEW: Smart categorization and impact calculation
            function calculateItemImpact(item) {
                let impact = 0;

                // Impact based on item type
                const typeImpacts = {
                    'collections': 80,
                    'charge_offs': 75,
                    'charge-offs': 75,
                    'late_payments': 60,
                    'payment_history': 60,
                    'public_records': 70,
                    'inquiries': 30,
                    'duplicates': 50,
                    'personal_info': 20,
                    'high_balances': 40,
                    'account_status': 45
                };

                const itemType = item.analysis_pass || item.issue_type || 'other';
                impact += typeImpacts[itemType] || 25;

                // Boost for high confidence
                if (item.confidence_level === 'high') impact += 20;
                if (item.confidence_level === 'medium') impact += 10;

                // Boost for specific dispute reasons
                const disputeReason = (item.dispute_reason || '').toLowerCase();
                if (disputeReason.includes('error') || disputeReason.includes('inaccurate')) impact += 15;
                if (disputeReason.includes('unverified') || disputeReason.includes('validation')) impact += 10;

                return Math.min(impact, 100); // Cap at 100
            }

            function groupItemsByImpactAndType(items) {
                if (!items || items.length === 0) return null;

                // Calculate impact for each item
                const itemsWithImpact = items.map(item => ({
                    ...item,
                    calculatedImpact: calculateItemImpact(item)
                }));

                // Group by impact level
                const highImpact = itemsWithImpact.filter(item => item.calculatedImpact >= 65);
                const mediumImpact = itemsWithImpact.filter(item => item.calculatedImpact >= 35 && item.calculatedImpact < 65);
                const lowImpact = itemsWithImpact.filter(item => item.calculatedImpact < 35);

                // Further group by type within each impact level
                const groupByType = (items) => {
                    const grouped = {};
                    items.forEach(item => {
                        const type = item.analysis_pass || item.issue_type || 'other';
                        if (!grouped[type]) {
                            grouped[type] = {
                                type: type,
                                displayName: formatCategoryName(type),
                                items: [],
                                avgImpact: 0
                            };
                        }
                        grouped[type].items.push(item);
                    });

                    // Calculate average impact for each type
                    Object.values(grouped).forEach(group => {
                        group.avgImpact = group.items.reduce((sum, item) => sum + item.calculatedImpact, 0) / group.items.length;
                        group.items.sort((a, b) => b.calculatedImpact - a.calculatedImpact);
                    });

                    return Object.values(grouped).sort((a, b) => b.avgImpact - a.avgImpact);
                };

                return {
                    high_impact: {
                        level: 'High Impact',
                        description: 'Biggest score boost potential',
                        emoji: '🎯',
                        items: highImpact,
                        groups: groupByType(highImpact),
                        totalItems: highImpact.length
                    },
                    medium_impact: {
                        level: 'Medium Impact',
                        description: 'Moderate score improvement',
                        emoji: '📊',
                        items: mediumImpact,
                        groups: groupByType(mediumImpact),
                        totalItems: mediumImpact.length
                    },
                    low_impact: {
                        level: 'Low Impact',
                        description: 'Small but worthwhile gains',
                        emoji: '📈',
                        items: lowImpact,
                        groups: groupByType(lowImpact),
                        totalItems: lowImpact.length
                    }
                };
            }

            function calculateScoreImpact(selectedCount) {
                // Rough estimate: each high-impact item could boost score 10-30 points
                return Math.min(selectedCount * 15, 150);
            }

            // NEW: Conversation flow functions
            function startDisputeConversationFlow(container) {
                if (!currentAnalysisData || !currentAnalysisData.extractedItems) {
                    addBotMessage("I don't have any analysis data. Please analyze your reports first.");
                    return;
                }

                // Initialize conversation state
                conversationState.groupedItems = groupItemsByImpactAndType(currentAnalysisData.extractedItems);
                conversationState.phase = 'overview';
                conversationState.selectedItems = [];
                conversationState.skippedItems = [];
                conversationState.completedCategories = [];

                showDisputeOverview(container);
            }

            function showDisputeOverview(container) {
                const grouped = conversationState.groupedItems;
                if (!grouped) return;

                const totalItems = currentAnalysisData.extractedItems.length;

                addBotMessageWithButtons(
                    `🎯 **Strategic Dispute Plan**
                    
                    I found **${totalItems} potential dispute items**. Let's be smart about this!
                    
                    📊 **Impact Breakdown:**
                    • ${grouped.high_impact.emoji} **${grouped.high_impact.totalItems} High Impact** - ${grouped.high_impact.description}
                    • ${grouped.medium_impact.emoji} **${grouped.medium_impact.totalItems} Medium Impact** - ${grouped.medium_impact.description}  
                    • ${grouped.low_impact.emoji} **${grouped.low_impact.totalItems} Low Impact** - ${grouped.low_impact.description}
                    
                    💡 **My Recommendation:** Start with high-impact items for maximum score improvement!`,
                    [
                        { text: `🎯 Start with High Impact (${grouped.high_impact.totalItems})`, value: "start_high_impact" },
                        { text: "📋 See All Categories", value: "show_all_categories" },
                        { text: "🤔 Explain Impact Levels", value: "explain_impact_levels" },
                        { text: "⚡ Quick Auto-Select", value: "auto_select_best" }
                    ]
                );

                updateMessagesDisplay(container);
                saveState();
            }

            function showImpactLevelExplanation(container) {
                addBotMessageWithButtons(
                    `🎓 **Understanding Impact Levels**
                    
                    **🎯 High Impact (65+ points)**
                    Collections, charge-offs, major derogatory marks
                    *Potential: +15-30 credit score points each*
                    
                    **📊 Medium Impact (35-64 points)**  
                    Late payments, inquiries, account errors
                    *Potential: +5-15 credit score points each*
                    
                    **📈 Low Impact (Under 35 points)**
                    Personal info errors, minor discrepancies  
                    *Potential: +2-8 credit score points each*
                    
                    💰 **Smart Strategy:** Focus on high-impact items first for fastest results!`,
                    [
                        { text: "🎯 Got it! Start with High Impact", value: "start_high_impact" },
                        { text: "🔄 Back to Overview", value: "back_to_overview" }
                    ]
                );

                updateMessagesDisplay(container);
                saveState();
            }

            function showImpactCategory(impactLevel, container) {
                const grouped = conversationState.groupedItems;
                const category = grouped[impactLevel];

                if (!category || category.totalItems === 0) {
                    addBotMessage(`No items found in the ${category?.level || impactLevel} category.`);
                    updateMessagesDisplay(container);
                    return;
                }

                conversationState.phase = 'category';
                conversationState.currentCategory = impactLevel;

                let message = `${category.emoji} **${category.level} Items (${category.totalItems} total)**\n\n`;
                message += `${category.description}\n\n`;

                if (category.groups.length > 0) {
                    message += `**Categories to review:**\n\n`;
                    category.groups.forEach((group, index) => {
                        const avgImpact = Math.round(group.avgImpact);
                        message += `${getTypeEmoji(group.type)} **${group.displayName}** (${group.items.length} items, ~${avgImpact} impact)\n`;
                    });
                } else {
                    message += `No items available in this category.`;
                }

                const buttons = [];

                if (category.groups.length > 0) {
                    // Add buttons for each category group
                    category.groups.slice(0, 3).forEach(group => { // Limit to top 3 groups
                        buttons.push({
                            text: `${getTypeEmoji(group.type)} ${group.displayName} (${group.items.length})`,
                            value: `review_group_${impactLevel}_${group.type}`
                        });
                    });

                    if (category.groups.length > 3) {
                        buttons.push({ text: "📋 See More Categories", value: `show_more_groups_${impactLevel}` });
                    }
                }

                buttons.push({ text: "🔄 Back to Overview", value: "back_to_overview" });

                addBotMessageWithButtons(message, buttons);
                updateMessagesDisplay(container);
                saveState();
            }

            function reviewItemGroup(impactLevel, groupType, container) {
                const grouped = conversationState.groupedItems;
                const category = grouped[impactLevel];
                const group = category.groups.find(g => g.type === groupType);

                if (!group || group.items.length === 0) {
                    addBotMessage("No items found in this group.");
                    updateMessagesDisplay(container);
                    return;
                }

                conversationState.phase = 'item_review';
                conversationState.currentItemIndex = 0;

                showItemForReview(group.items, 0, impactLevel, groupType, container);
            }

            function showItemForReview(items, index, impactLevel, groupType, container) {
                if (index >= items.length) {
                    // Finished reviewing this group
                    showGroupCompletionSummary(impactLevel, groupType, container);
                    return;
                }

                const item = items[index];
                const isFirst = index === 0;
                const isLast = index === items.length - 1;

                let message = '';

                if (isFirst) {
                    const grouped = conversationState.groupedItems;
                    const category = grouped[impactLevel];
                    const group = category.groups.find(g => g.type === groupType);
                    message += `${getTypeEmoji(groupType)} **${group.displayName} Review**\n\n`;
                }

                message += `**Item ${index + 1} of ${items.length}**\n\n`;
                message += `🏢 **Creditor:** ${item.creditor_name || 'Unknown'}\n`;
                message += `💳 **Account:** ${item.account_number || 'N/A'}\n`;
                if (item.amount) message += `💰 **Amount:** $${item.amount}\n`;
                message += `⚠️ **Issue:** ${item.dispute_reason || 'General dispute'}\n`;
                message += `🎯 **Impact Score:** ${Math.round(item.calculatedImpact)}/100\n\n`;

                message += `**💡 Why dispute this:**\n${getDisputeStrategy(groupType)}\n\n`;
                message += `**📈 Success Rate:** ${getSuccessRate(groupType)}`;

                const buttons = [
                    { text: "✅ Yes, dispute this", value: `select_item_${item.id || index}_${impactLevel}_${groupType}` },
                    { text: "❓ Need more info", value: `explain_item_${item.id || index}_${impactLevel}_${groupType}` },
                    { text: "⏭️ Skip this one", value: `skip_item_${item.id || index}_${impactLevel}_${groupType}` }
                ];

                if (!isLast) {
                    buttons.push({ text: `⏯️ Select All Remaining (${items.length - index})`, value: `select_all_remaining_${impactLevel}_${groupType}` });
                }

                addBotMessageWithButtons(message, buttons);
                updateMessagesDisplay(container);
                saveState();
            }

            function getTypeEmoji(type) {
                const emojiMap = {
                    'collections': '🏦',
                    'charge_offs': '💳',
                    'charge-offs': '💳',
                    'late_payments': '⏰',
                    'payment_history': '⏰',
                    'inquiries': '🔍',
                    'duplicates': '👥',
                    'personal_info': '👤',
                    'public_records': '📋',
                    'high_balances': '💰',
                    'account_status': '📊',
                    'other': '📄'
                };
                return emojiMap[type] || '📄';
            }

            function getDisputeStrategy(type) {
                const strategies = {
                    'collections': 'Request debt validation - they must prove this debt is yours and accurate',
                    'charge_offs': 'Challenge accuracy of dates, amounts, or account status',
                    'charge-offs': 'Challenge accuracy of dates, amounts, or account status',
                    'late_payments': 'Request goodwill removal or dispute inaccurate payment dates',
                    'payment_history': 'Verify payment dates and amounts for accuracy',
                    'inquiries': 'Challenge unauthorized credit pulls or outdated inquiries',
                    'duplicates': 'Request removal of duplicate accounts reporting the same debt',
                    'personal_info': 'Correct inaccurate personal information affecting your profile',
                    'public_records': 'Verify accuracy of court records and dates',
                    'high_balances': 'Dispute incorrect balance amounts or account limits'
                };
                return strategies[type] || 'Challenge the accuracy and completeness of this item';
            }

            function getSuccessRate(type) {
                const rates = {
                    'collections': '65%',
                    'charge_offs': '55%',
                    'charge-offs': '55%',
                    'late_payments': '45%',
                    'payment_history': '50%',
                    'inquiries': '75%',
                    'duplicates': '80%',
                    'personal_info': '90%',
                    'public_records': '60%',
                    'high_balances': '70%'
                };
                return rates[type] || '60%';
            }

            function showGroupCompletionSummary(impactLevel, groupType, container) {
                const grouped = conversationState.groupedItems;
                const category = grouped[impactLevel];
                const group = category.groups.find(g => g.type === groupType);

                const selectedFromGroup = conversationState.selectedItems.filter(item =>
                    (item.analysis_pass === groupType || item.issue_type === groupType) &&
                    item.calculatedImpact >= (impactLevel === 'high_impact' ? 65 : impactLevel === 'medium_impact' ? 35 : 0)
                );

                let message = `✅ **${group.displayName} Complete!**\n\n`;
                message += `📊 **Results:** ${selectedFromGroup.length}/${group.items.length} items selected for dispute\n`;
                message += `📈 **Potential Impact:** +${selectedFromGroup.length * 15} credit score points\n\n`;

                // Show next steps
                const remainingGroups = category.groups.filter(g =>
                    !conversationState.completedCategories.includes(`${impactLevel}_${g.type}`)
                );

                const buttons = [];

                if (remainingGroups.length > 1) {
                    const nextGroup = remainingGroups.find(g => g.type !== groupType);
                    if (nextGroup) {
                        buttons.push({
                            text: `▶️ Next: ${nextGroup.displayName} (${nextGroup.items.length})`,
                            value: `review_group_${impactLevel}_${nextGroup.type}`
                        });
                    }
                }

                buttons.push({ text: "📊 Show Progress Summary", value: "show_progress" });
                buttons.push({ text: "🔄 Back to Categories", value: `show_impact_${impactLevel}` });

                if (conversationState.selectedItems.length > 0) {
                    buttons.push({ text: "📄 Generate Dispute Letters", value: "generate_letters" });
                }

                // Mark this group as completed
                conversationState.completedCategories.push(`${impactLevel}_${groupType}`);

                addBotMessageWithButtons(message, buttons);
                updateMessagesDisplay(container);
                saveState();
            }

            function showProgress(container) {
                const total = currentAnalysisData.extractedItems.length;
                const reviewed = conversationState.selectedItems.length + conversationState.skippedItems.length;
                const selected = conversationState.selectedItems.length;
                const scoreImpact = calculateScoreImpact(selected);

                // Break down by category
                const grouped = conversationState.groupedItems;
                let breakdown = '';

                ['high_impact', 'medium_impact', 'low_impact'].forEach(level => {
                    const category = grouped[level];
                    const selectedFromCategory = conversationState.selectedItems.filter(item => {
                        const impact = item.calculatedImpact;
                        return level === 'high_impact' ? impact >= 65 :
                            level === 'medium_impact' ? (impact >= 35 && impact < 65) :
                                impact < 35;
                    });

                    breakdown += `• ${category.emoji} ${category.level}: ${selectedFromCategory.length}/${category.totalItems} selected\n`;
                });

                let message = `📊 **Your Dispute Progress**\n\n`;
                message += `✅ **Reviewed:** ${reviewed}/${total} items\n`;
                message += `🎯 **Selected for dispute:** ${selected} items\n`;
                message += `📈 **Potential score boost:** +${scoreImpact} points\n\n`;
                message += `**Breakdown:**\n${breakdown}\n`;
                message += `💪 Keep going! You're making excellent progress!`;

                const buttons = [];

                if (reviewed < total) {
                    buttons.push({ text: "▶️ Continue Reviewing", value: "continue_review" });
                }

                if (selected > 0) {
                    buttons.push({ text: "📄 Generate Letters Now", value: "generate_letters" });
                }

                buttons.push({ text: "🔄 Back to Overview", value: "back_to_overview" });

                addBotMessageWithButtons(message, buttons);
                updateMessagesDisplay(container);
                saveState();
            }

            // Private core functions
            function addBotMessage(content, buttons = null) {
                const message = {
                    id: Date.now() + Math.random(),
                    type: 'bot',
                    content: content,
                    timestamp: new Date().toISOString(),
                    buttons: buttons
                };
                messages.push(message);
                return message;
            }

            function addUserMessage(content) {
                const message = {
                    id: Date.now() + Math.random(),
                    type: 'user',
                    content: content,
                    timestamp: new Date().toISOString()
                };
                messages.push(message);
                return message;
            }

            function addBotMessageWithButtons(content, buttons) {
                return addBotMessage(content, buttons);
            }

            function showTypingIndicator(container) {
                const messagesContainer = container.querySelector('.Bot-chat-messages');
                if (!messagesContainer) return;

                hideTypingIndicator(container);

                typingIndicator = document.createElement('div');
                typingIndicator.className = 'Bot-message bot typing-indicator';
                typingIndicator.innerHTML = `
                    <div class="Bot-message-avatar">🤖</div>
                    <div class="Bot-message-content">
                        <div class="typing-dots">
                            <span></span>
                            <span></span>
                            <span></span>
                        </div>
                    </div>
                `;

                messagesContainer.appendChild(typingIndicator);
                messagesContainer.scrollTop = messagesContainer.scrollHeight;
            }

            function hideTypingIndicator(container) {
                if (typingIndicator) {
                    typingIndicator.remove();
                    typingIndicator = null;
                }
            }

            function renderChatInterface(container) {
                const chatHtml = `
                    <div class="Bot-chat-container">
                        <div class="Bot-chat-messages" id="Bot-chat-messages"></div>
                    </div>
                `;

                container.innerHTML = chatHtml;
                // No need for event listeners since we're removing the input interface
            }

            function setupChatEventListeners(container) {
                const input = container.querySelector('#Bot-chat-input');
                const sendButton = container.querySelector('#Bot-chat-send');

                if (input && sendButton) {
                    input.addEventListener('input', function () {
                        sendButton.disabled = !this.value.trim();
                        this.style.height = 'auto';
                        this.style.height = Math.min(this.scrollHeight, 100) + 'px';
                    });

                    input.addEventListener('keydown', function (e) {
                        if (e.key === 'Enter' && !e.shiftKey) {
                            e.preventDefault();
                            if (this.value.trim()) {
                                sendMessage(this.value.trim(), container);
                                this.value = '';
                                this.style.height = 'auto';
                                sendButton.disabled = true;
                            }
                        }
                    });

                    sendButton.addEventListener('click', function () {
                        const message = input.value.trim();
                        if (message) {
                            sendMessage(message, container);
                            input.value = '';
                            input.style.height = 'auto';
                            this.disabled = true;
                        }
                    });
                }
            }

            function sendMessage(message, container) {
                addUserMessage(message);
                updateMessagesDisplay(container);
                // Don't save - we want fresh conversations each time

                showTypingIndicator(container);

                setTimeout(() => {
                    hideTypingIndicator(container);
                    addBotMessage("I'm JAM Dispute Bot, and I'm here to help! Could you please be more specific about what you'd like assistance with regarding credit repair?");
                    updateMessagesDisplay(container);
                    // Don't save - we want fresh conversations each time
                }, 1500);
            }

            function updateMessagesDisplay(container) {
                const messagesContainer = container.querySelector('.Bot-chat-messages');
                if (!messagesContainer) return;

                const existingTyping = messagesContainer.querySelector('.typing-indicator');
                if (existingTyping) {
                    typingIndicator = existingTyping;
                }

                messagesContainer.innerHTML = '';

                messages.forEach(message => {
                    const messageElement = document.createElement('div');
                    messageElement.className = `Bot-message ${message.type}`;

                    if (message.type === 'bot') {
                        messageElement.innerHTML = `
                            <div class="Bot-message-avatar">🤖</div>
                            <div class="Bot-message-content">
                                ${formatMessageContent(message.content)}
                                ${message.buttons ? renderMessageButtons(message.buttons) : ''}
                            </div>
                        `;
                    } else {
                        messageElement.innerHTML = `
                            <div class="Bot-message-content">${formatMessageContent(message.content)}</div>
                            <div class="Bot-message-avatar">👤</div>
                        `;
                    }

                    messagesContainer.appendChild(messageElement);
                });

                if (typingIndicator) {
                    messagesContainer.appendChild(typingIndicator);
                }

                messagesContainer.scrollTop = messagesContainer.scrollHeight;
            }

            function renderMessageButtons(buttons) {
                if (!buttons || !Array.isArray(buttons)) return '';

                const buttonsHtml = buttons.map(button =>
                    `<button class="Bot-chat-button" onclick="ChatModule.handleButtonClick('${button.value}', this.closest('.Bot-chat-container'))">${button.text}</button>`
                ).join('');

                return `<div class="Bot-message-buttons">${buttonsHtml}</div>`;
            }

            function saveState(forceSave = false) {
                // UPDATED: Only save state if explicitly requested or during active conversation
                // Since we want fresh conversations each time, we won't auto-save
                if (!forceSave) {
                    debugLog('saveState', 'SKIPPED - Fresh conversations enabled');
                    return;
                }

                try {
                    localStorage.setItem('jamBotChatMessages', JSON.stringify(messages));
                    localStorage.setItem('jamBotChatState', JSON.stringify({
                        messages: messages,
                        currentAnalysisData: currentAnalysisData,
                        conversationState: conversationState,
                        timestamp: new Date().toISOString()
                    }));
                    debugLog('saveState', 'SUCCESS - State saved to localStorage');
                } catch (error) {
                    console.error('Error saving chat state:', error);
                }
            }

            function loadState() {
                try {
                    const savedMessages = localStorage.getItem('jamBotChatMessages');
                    const savedState = localStorage.getItem('jamBotChatState');

                    if (savedMessages) {
                        messages = JSON.parse(savedMessages);
                    }

                    if (savedState) {
                        const state = JSON.parse(savedState);
                        if (state.currentAnalysisData) {
                            currentAnalysisData = state.currentAnalysisData;
                        }
                        if (state.conversationState) {
                            // Restore conversation state
                            conversationState = {
                                ...conversationState,
                                ...state.conversationState
                            };
                        }
                        return true;
                    }
                } catch (error) {
                    console.error('Error loading chat state:', error);
                }
                return false;
            }

            async function checkForUploadedReports() {
                try {
                    console.log('🔍 Checking for uploaded credit reports...');

                    // Try to get user identifier and ID
                    let userIdentifier = null;
                    let userId = null;

                    // Method 1: URL parameters
                    const urlParams = new URLSearchParams(window.location.search);
                    userIdentifier = urlParams.get('userEmail') || urlParams.get('email') || urlParams.get('user');

                    // Method 2: Check localStorage for user info (PRIMARY METHOD)
                    if (!userIdentifier) {
                        const savedUserData = localStorage.getItem('userData');
                        if (savedUserData) {
                            const userData = JSON.parse(savedUserData);
                            userIdentifier = userData.email || userData.userEmail;
                            userId = userData.id;
                            console.log('Found user identifier from userData:', userIdentifier);
                            console.log('Found user ID from userData:', userId);
                        }

                        // Fallback to old key name
                        if (!userIdentifier) {
                            const savedUserInfo = localStorage.getItem('jamBotUserInfo');
                            if (savedUserInfo) {
                                const userInfo = JSON.parse(savedUserInfo);
                                userIdentifier = userInfo.email || userInfo.userEmail;
                                userId = userInfo.id;
                                console.log('Found user identifier from jamBotUserInfo:', userIdentifier);
                            }
                        }
                    }

                    if (!userIdentifier || !userId) {
                        console.log('❌ No user identifier or ID found - no reports available');
                        return { hasReports: false, count: 0, reports: [], source: 'no_user' };
                    }

                    // Get auth token
                    const authToken = localStorage.getItem('authToken') ||
                        localStorage.getItem('token') ||
                        sessionStorage.getItem('authToken') ||
                        sessionStorage.getItem('token');

                    if (!authToken) {
                        console.log('❌ No auth token found - cannot check backend');
                        return { hasReports: false, count: 0, reports: [], source: 'no_auth' };
                    }

                    console.log('🌐 Checking backend for reports with user ID:', userId);

                    // Make backend request to get user documents
                    const response = await fetch(`http://localhost:3000/api/admin/get-user-documents?userId=${userId}`, {
                        method: 'GET',
                        headers: {
                            'Authorization': `Bearer ${authToken}`,
                            'Content-Type': 'application/json'
                        }
                    });

                    if (!response.ok) {
                        console.log(`❌ Backend request failed with status: ${response.status}`);
                        return { hasReports: false, count: 0, reports: [], source: 'backend_failed' };
                    }

                    const result = await response.json();
                    console.log('📊 Backend response:', result);

                    // Filter for credit reports specifically
                    const creditReports = result.documents ?
                        result.documents.filter(doc => doc.documentType === 'credit-report') : [];

                    const reportCount = creditReports.length;

                    console.log(`✅ Found ${reportCount} credit reports for user ${userIdentifier}`);
                    console.log('📋 Credit reports:', creditReports.map(r => ({
                        fileName: r.fileName,
                        bureau: r.bureau,
                        uploadedBy: r.uploadedBy,
                        createdAt: r.createdAt
                    })));

                    // Only return true if we have actual credit reports from backend
                    const hasActualReports = reportCount > 0;

                    return {
                        hasReports: hasActualReports,
                        count: reportCount,
                        reports: creditReports,
                        source: 'backend'
                    };

                } catch (error) {
                    console.error('❌ Error checking for uploaded reports:', error);

                    // For any errors, return false - we don't want to show the question if we can't verify
                    return {
                        hasReports: false,
                        count: 0,
                        reports: [],
                        source: 'error',
                        error: error.message
                    };
                }
            }

            async function analyzeBackendReports(container) {
                try {
                    console.log('=== ANALYZING BACKEND REPORTS ===');

                    // Try to get user email from multiple sources
                    let userEmail = null;

                    // Method 1: URL parameters
                    const urlParams = new URLSearchParams(window.location.search);
                    userEmail = urlParams.get('userEmail') || urlParams.get('email');

                    // Method 2: Check localStorage for userData (PRIMARY METHOD)
                    if (!userEmail) {
                        const savedUserData = localStorage.getItem('userData');
                        if (savedUserData) {
                            const userData = JSON.parse(savedUserData);
                            userEmail = userData.email;
                            console.log('Found user email from userData:', userEmail);
                        }
                    }

                    // Method 3: Fallback to old localStorage key
                    if (!userEmail) {
                        const savedUserInfo = localStorage.getItem('jamBotUserInfo');
                        if (savedUserInfo) {
                            const userInfo = JSON.parse(savedUserInfo);
                            userEmail = userInfo.email || userInfo.userEmail;
                            console.log('Found user email from jamBotUserInfo:', userEmail);
                        }
                    }

                    if (!userEmail) {
                        console.error('No user email found in URL parameters or localStorage');
                        hideTypingIndicator(container);
                        addBotMessage("I couldn't identify your account. Please refresh the page and try again.");
                        updateMessagesDisplay(container);
                        saveState();
                        return;
                    }

                    console.log('Analyzing reports for user:', userEmail);

                    // ENHANCED: Show progressive analysis with educational content
                    hideTypingIndicator(container);
                    showProgressiveAnalysis(container, userEmail);

                } catch (error) {
                    console.error('=== ANALYSIS ERROR ===', error);

                    hideTypingIndicator(container);

                    let errorMessage = "I encountered an error while analyzing your reports. ";

                    if (error.message.includes('404')) {
                        errorMessage += "It looks like you haven't uploaded any credit reports yet. Please upload your reports in the Reports tab first.";
                    } else if (error.message.includes('500')) {
                        errorMessage += "There was a server error. Please try again in a few moments.";
                    } else {
                        errorMessage += "Please try again or contact support if the problem persists.";
                    }

                    addBotMessage(errorMessage);
                    updateMessagesDisplay(container);
                    saveState();

                    debugLog('analyzeBackendReports', 'ERROR', { error: error.message });
                }
            }

            // NEW: Progressive analysis with educational content and status updates
            async function showProgressiveAnalysis(container, userEmail) {
                const steps = [
                    {
                        message: "🔍 **Starting Deep Analysis...**\n\nI'm examining your credit reports line by line to identify potential disputes.",
                        duration: 2000,
                        tip: "💡 **Did you know?** The Fair Credit Reporting Act gives you the right to dispute any inaccurate information on your credit reports."
                    },
                    {
                        message: "📊 **Scanning Personal Information...**\n\nChecking for incorrect names, addresses, employment, or other personal details.",
                        duration: 2500,
                        tip: "⚡ **Quick Tip:** Personal information errors are often the easiest disputes to win - 90% success rate!"
                    },
                    {
                        message: "💳 **Analyzing Account Data...**\n\nReviewing payment histories, balances, and account statuses for inconsistencies.",
                        duration: 3000,
                        tip: "📈 **Impact:** Removing just one collection account can boost your score by 20-50 points!"
                    },
                    {
                        message: "🏦 **Cross-Referencing Creditors...**\n\nComparing information across all three bureaus to find discrepancies.",
                        duration: 2500,
                        tip: "🎯 **Strategy:** Different bureaus often have different information - we can dispute mismatches!"
                    },
                    {
                        message: "⚖️ **Checking Legal Compliance...**\n\nVerifying dates, amounts, and account details meet legal reporting standards.",
                        duration: 3500,
                        tip: "📚 **Fact:** Credit bureaus must remove items they can't verify within 30 days of your dispute."
                    },
                    {
                        message: "🔬 **AI Pattern Recognition...**\n\nUsing advanced algorithms to identify subtle errors and opportunities.",
                        duration: 3000,
                        tip: "🤖 **AI Power:** Our system catches errors human eyes might miss, like inconsistent reporting patterns."
                    },
                    {
                        message: "📋 **Compiling Dispute Opportunities...**\n\nPrioritizing items by impact potential and success probability.",
                        duration: 2000,
                        tip: "🎯 **Smart Strategy:** We focus on high-impact items first for maximum score improvement!"
                    }
                ];

                let currentStep = 0;
                let progressMessageId = null;

                // Function to update the progress message
                const updateProgress = () => {
                    if (currentStep < steps.length) {
                        const step = steps[currentStep];
                        const progressPercent = Math.round(((currentStep + 1) / steps.length) * 100);

                        let progressMessage = `${step.message}\n\n`;
                        progressMessage += `📊 **Progress:** ${progressPercent}% Complete\n\n`;
                        progressMessage += `${step.tip}\n\n`;

                        // Add visual progress bar
                        const filledBars = Math.floor(progressPercent / 10);
                        const emptyBars = 10 - filledBars;
                        const progressBar = '🟦'.repeat(filledBars) + '⬜'.repeat(emptyBars);
                        progressMessage += `${progressBar} ${progressPercent}%`;

                        if (progressMessageId) {
                            // Update the existing message
                            const existingMessage = messages.find(msg => msg.id === progressMessageId);
                            if (existingMessage) {
                                existingMessage.content = progressMessage;
                            }
                        } else {
                            // Create new progress message
                            const message = addBotMessage(progressMessage);
                            progressMessageId = message.id;
                        }

                        updateMessagesDisplay(container);
                        currentStep++;

                        // Schedule next update
                        setTimeout(updateProgress, step.duration);
                    } else {
                        // All steps complete, now perform actual analysis
                        performActualAnalysis(userEmail, container, progressMessageId);
                    }
                };

                // Start the progress updates
                updateProgress();
            }

            // NEW: Continuous waiting animation for API processing
            let waitingInterval = null;
            let waitingMessageId = null;
            let waitingTipIndex = 0;

            const waitingTips = [
                "🔍 **Deep Scanning:** Analyzing every line of your credit reports for inaccuracies...",
                "⚖️ **Legal Review:** Checking compliance with Fair Credit Reporting Act standards...",
                "🎯 **Strategy Building:** Calculating the best dispute approach for maximum impact...",
                "📊 **Impact Analysis:** Determining which items will boost your score the most...",
                "🔬 **AI Processing:** Using machine learning to identify subtle reporting errors...",
                "💡 **Opportunity Detection:** Finding dispute opportunities you might have missed...",
                "📈 **Score Modeling:** Predicting your potential credit score improvements...",
                "🛡️ **Validation Check:** Ensuring all dispute reasons meet legal requirements...",
                "🎪 **Final Assembly:** Compiling your personalized dispute strategy..."
            ];

            async function startContinuousWaiting(container, originalProgressMessageId) {
                // Create initial waiting message
                const waitingMessage = addBotMessage(
                    "⏳ **Processing Your Analysis...**\n\nThis may take a moment as we thoroughly examine your credit reports.\n\n🔍 **Deep Scanning:** Analyzing every line of your credit reports for inaccuracies...\n\n" +
                    "🟦🟦🟦⬜⬜⬜⬜⬜⬜⬜ Processing..."
                );
                waitingMessageId = waitingMessage.id;
                updateMessagesDisplay(container);

                // Start continuous updates every 3 seconds
                waitingInterval = setInterval(() => {
                    if (waitingMessageId) {
                        waitingTipIndex = (waitingTipIndex + 1) % waitingTips.length;
                        const currentTip = waitingTips[waitingTipIndex];

                        // Create animated progress bars
                        const progressBarOptions = [
                            "🟦🟦🟦🟦⬜⬜⬜⬜⬜⬜",
                            "🟦🟦🟦🟦🟦🟦⬜⬜⬜⬜",
                            "🟦🟦🟦🟦🟦🟦🟦🟦⬜⬜",
                            "🟦🟦🟦🟦🟦🟦🟦🟦🟦🟦"
                        ];
                        const progressBar = progressBarOptions[waitingTipIndex % progressBarOptions.length];

                        const updatedMessage = "⏳ **Processing Your Analysis...**\n\nThis may take a moment as we thoroughly examine your credit reports.\n\n" +
                            currentTip + "\n\n" +
                            progressBar + " Processing...";

                        const existingMessage = messages.find(msg => msg.id === waitingMessageId);
                        if (existingMessage) {
                            existingMessage.content = updatedMessage;
                            updateMessagesDisplay(container);
                        }
                    }
                }, 3000);

                return waitingMessageId;
            }

            function stopContinuousWaiting() {
                if (waitingInterval) {
                    clearInterval(waitingInterval);
                    waitingInterval = null;
                }

                if (waitingMessageId) {
                    // Update the waiting message to show completion
                    const existingMessage = messages.find(msg => msg.id === waitingMessageId);
                    if (existingMessage) {
                        existingMessage.content = "✅ **Analysis Processing Complete!**\n\nGenerating your comprehensive dispute strategy...\n\n🟦🟦🟦🟦🟦🟦🟦🟦🟦🟦 Complete!";
                    }
                    waitingMessageId = null;
                }

                // Reset the tip index for next time
                waitingTipIndex = 0;
            }

            // NEW: Perform the actual analysis call
            async function performActualAnalysis(userEmail, container, progressMessageId) {
                try {
                    // Final status update
                    const finalMessage = "🚀 **Analysis Complete!**\n\nProcessing results and generating your personalized dispute strategy...\n\n📊 **Progress:** 100% Complete\n\n✨ **Almost done!** Preparing your comprehensive credit report analysis.";

                    if (progressMessageId) {
                        const existingMessage = messages.find(msg => msg.id === progressMessageId);
                        if (existingMessage) {
                            existingMessage.content = finalMessage;
                        }
                    }
                    updateMessagesDisplay(container);

                    // Small delay for dramatic effect
                    await new Promise(resolve => setTimeout(resolve, 1500));

                    // Start continuous waiting animation for the API processing
                    const waitingMessageId = await startContinuousWaiting(container, progressMessageId);

                    // Now make the actual API call
                    const response = await fetch(`http://localhost:3000/api/chat/analyze?userEmail=${encodeURIComponent(userEmail)}`, {
                        method: 'GET',
                        headers: {
                            'Content-Type': 'application/json'
                        }
                    });

                    console.log('Analysis request sent, response status:', response.status);

                    if (!response.ok) {
                        const errorText = await response.text();
                        console.error('Server error:', errorText);
                        throw new Error(`Server error: ${response.status} - ${errorText}`);
                    }

                    const data = await response.json();

                    // Stop the continuous waiting animation
                    stopContinuousWaiting();

                    // Small delay to show completion animation
                    await new Promise(resolve => setTimeout(resolve, 1000));

                    console.log('=== ANALYSIS RESPONSE DEBUG ===');
                    console.log('Response data keys:', Object.keys(data));
                    console.log('Response data.extractedItems exists:', !!data.extractedItems);
                    console.log('Response data.extractedItems length:', data.extractedItems?.length || 'N/A');

                    if (data.error) {
                        throw new Error(data.error);
                    }

                    // Store analysis results
                    currentAnalysisData = data;
                    localStorage.setItem('jamBotLastAnalysis', JSON.stringify(data));
                    localStorage.setItem('creditReportAnalysis', JSON.stringify(data));
                    localStorage.setItem('lastAnalysisData', JSON.stringify(data));

                    // Show results with enhanced presentation
                    showAnalysisResults(data, container, progressMessageId);

                    debugLog('performActualAnalysis', 'SUCCESS', { extractedItemsCount: data.extractedItems?.length });

                } catch (error) {
                    console.error('=== ANALYSIS ERROR ===', error);

                    // Stop the continuous waiting animation on error
                    stopContinuousWaiting();

                    let errorMessage = "❌ **Analysis Error**\n\nI encountered an error while analyzing your reports. ";

                    if (error.message.includes('404')) {
                        errorMessage += "It looks like you haven't uploaded any credit reports yet. Please upload your reports in the Reports tab first.";
                    } else if (error.message.includes('500')) {
                        errorMessage += "There was a server error. Please try again in a few moments.";
                    } else {
                        errorMessage += "Please try again or contact support if the problem persists.";
                    }

                    // Update the progress message to show error
                    if (progressMessageId) {
                        const existingMessage = messages.find(msg => msg.id === progressMessageId);
                        if (existingMessage) {
                            existingMessage.content = errorMessage;
                        }
                    } else {
                        addBotMessage(errorMessage);
                    }

                    updateMessagesDisplay(container);
                    saveState();

                    debugLog('performActualAnalysis', 'ERROR', { error: error.message });
                }
            }

            // NEW: Enhanced results presentation
            function showAnalysisResults(data, container, progressMessageId) {
                const itemCount = data.extractedItems?.length || 0;

                let resultsMessage = "🎉 **Analysis Complete!**\n\n";

                if (itemCount > 0) {
                    // Calculate potential impact
                    const estimatedScoreBoost = Math.min(itemCount * 12, 200);

                    resultsMessage += `✅ **Found ${itemCount} Dispute Opportunities**\n\n`;
                    resultsMessage += `📈 **Potential Score Boost:** +${estimatedScoreBoost} points\n`;
                    resultsMessage += `⚡ **Success Rate:** 65-85% (industry average)\n`;
                    resultsMessage += `⏱️ **Timeline:** Results in 30-45 days\n\n`;

                    if (itemCount >= 50) {
                        resultsMessage += `🎯 **Wow!** That's a lot of opportunities (${itemCount} total). Let me help you tackle them strategically for maximum impact.`;
                    } else if (itemCount >= 20) {
                        resultsMessage += `📊 **Excellent!** I found ${itemCount} potential dispute items. Let's prioritize them for best results.`;
                    } else {
                        resultsMessage += `✨ **Great news!** I found ${itemCount} potential dispute items. Ready to boost your credit score?`;
                    }

                    // Update progress message with results
                    if (progressMessageId) {
                        const existingMessage = messages.find(msg => msg.id === progressMessageId);
                        if (existingMessage) {
                            existingMessage.content = resultsMessage;
                        }
                    } else {
                        addBotMessage(resultsMessage);
                    }

                    // Add strategy buttons
                    const buttons = [
                        { text: "🎯 Start Smart Dispute Guide", value: "start_dispute" },
                        { text: "📊 Show High Priority Items", value: "show_high_priority" },
                        { text: "⚡ Auto-Select Best Items", value: "auto_select_best" },
                        { text: "📄 Generate All Letters Now", value: "view_letters" }
                    ];

                    // Additional context based on analysis
                    const analysisMessage = data.analysis || data.summary || '';
                    if (analysisMessage && analysisMessage.length > 10) {
                        addBotMessage(`📋 **Detailed Analysis:**\n\n${analysisMessage}`);
                    }

                    addBotMessageWithButtons(
                        "🚀 **What would you like to do next?**\n\nI recommend starting with the Smart Dispute Guide for the best strategy!",
                        buttons
                    );

                } else {
                    resultsMessage += `✅ **Great News!**\n\nI didn't find any items that appear to need disputing in your credit reports. Your reports look quite good!\n\n`;
                    resultsMessage += `🎯 **This means:**\n`;
                    resultsMessage += `• Your credit information appears accurate\n`;
                    resultsMessage += `• No obvious errors to dispute\n`;
                    resultsMessage += `• Your credit management is on track\n\n`;
                    resultsMessage += `💡 **Keep up the good work!** Focus on maintaining low balances and making on-time payments.`;

                    // Update progress message with results
                    if (progressMessageId) {
                        const existingMessage = messages.find(msg => msg.id === progressMessageId);
                        if (existingMessage) {
                            existingMessage.content = resultsMessage;
                        }
                    } else {
                        addBotMessage(resultsMessage);
                    }
                }

                updateMessagesDisplay(container);
                saveState();
            }

            function handleButtonClick(value, container) {
                debugLog('handleButtonClick', 'STARTED', { value: value });

                console.log('Button clicked:', value);

                // Original handlers
                if (value === 'analyze_reports') {
                    console.log('User clicked to analyze reports');
                    addUserMessage("Yes, analyze my reports");
                    showTypingIndicator(container);
                    analyzeBackendReports(container);

                } else if (value === 'skip_analysis') {
                    addUserMessage("No, I'll ask something else");
                    addBotMessage("No problem! Feel free to ask me anything about credit repair, dispute letters, or any other questions you might have.");
                    updateMessagesDisplay(container);
                    saveState();

                } else if (value === 'check_for_reports') {
                    addUserMessage("Yes, check for my reports");
                    addBotMessage("🔍 Let me check for your uploaded credit reports...");
                    showTypingIndicator(container);

                    checkForUploadedReports().then(hasReports => {
                        hideTypingIndicator(container);

                        if (hasReports.hasReports && hasReports.count > 0) {
                            addBotMessageWithButtons(
                                `✅ Great! I found ${hasReports.count} credit report${hasReports.count > 1 ? 's' : ''} in your account. Would you like me to analyze them for potential items to dispute?`,
                                [
                                    { text: "Yes, analyze my reports", value: "analyze_reports" },
                                    { text: "No, I'll ask something else", value: "skip_analysis" }
                                ]
                            );
                        } else {
                            addBotMessage(`❌ I couldn't find any credit reports in your account. Please upload your credit reports first in the Reports tab, then come back and I'll help you analyze them for dispute opportunities.`);
                        }
                        updateMessagesDisplay(container);
                    }).catch(error => {
                        hideTypingIndicator(container);
                        addBotMessage("❌ I encountered an error checking for your reports. Please try again or upload your reports if you haven't already.");
                        updateMessagesDisplay(container);
                        console.error('Error checking for reports:', error);
                    });

                } else if (value === 'no_reports_uploaded') {
                    addUserMessage("No, I haven't uploaded them yet");
                    addBotMessage("No problem! Here's what you need to do:\n\n📄 **Step 1:** Go to the **Reports tab** and upload your credit reports from all three bureaus (Experian, Equifax, TransUnion)\n\n🔍 **Step 2:** Come back to this chat and I'll analyze them for dispute opportunities\n\n💡 **Tip:** You can get free credit reports from annualcreditreport.com or through your credit monitoring service.");
                    updateMessagesDisplay(container);
                    saveState();

                } else if (value === 'start_dispute') {
                    addUserMessage("Yes, let's start the dispute process");
                    startDisputeConversationFlow(container);

                } else if (value === 'show_high_priority') {
                    addUserMessage("Show me high priority items");
                    showHighPriorityItems(container);
                    updateMessagesDisplay(container);
                    saveState();

                } else if (value === 'show_all_items') {
                    addUserMessage("Show me all items");
                    showAllItems(container);
                    updateMessagesDisplay(container);
                    saveState();

                } else if (value === 'view_letters') {
                    addUserMessage("Yes, show me the letters");

                    // Add generated letters to the LettersModule if available
                    const savedLetters = localStorage.getItem('jamBotGeneratedLetters');
                    if (savedLetters) {
                        try {
                            const letters = JSON.parse(savedLetters);
                            console.log('Found generated letters:', letters.length);

                            // Convert ChatGPT generated letters to LettersModule format
                            letters.forEach((letter, index) => {
                                const formattedLetter = {
                                    id: `generated_${Date.now()}_${index}`,
                                    name: `Dispute Letter - ${letter.bureau || `Letter ${index + 1}`}`,
                                    content: letter.letter || letter.content,
                                    createdAt: new Date().toISOString(),
                                    bureau: letter.bureau,
                                    itemCount: letter.itemCount || 0
                                };

                                // Add to LettersModule via parent
                                if (parentModule && parentModule.addGeneratedLetter) {
                                    parentModule.addGeneratedLetter(formattedLetter);
                                }
                            });

                            addBotMessage("🎉 I've added your generated dispute letters to the Letters tab! Switching you over now...");

                        } catch (error) {
                            console.error('Error processing generated letters:', error);
                        }
                    } else {
                        addBotMessage("🎉 Switching you to the Letters tab to view your dispute letters...");
                    }

                    // Switch to letters tab - try multiple methods to ensure it works
                    if (parentModule && typeof parentModule.switchTab === 'function') {
                        setTimeout(() => {
                            parentModule.switchTab('letters');
                        }, 1500);
                    } else if (window.jamTipBot && typeof window.jamTipBot.switchTab === 'function') {
                        setTimeout(() => {
                            window.jamTipBot.switchTab('letters');
                        }, 1500);
                    } else {
                        // Fallback - try to trigger a custom event
                        setTimeout(() => {
                            window.dispatchEvent(new CustomEvent('switchToLettersTab'));
                        }, 1500);
                    }

                    updateMessagesDisplay(container);
                    saveState();

                } else if (value === 'start_high_impact') {
                    addUserMessage("🎯 Start with High Impact items");
                    showImpactCategory('high_impact', container);

                } else if (value === 'show_all_categories') {
                    addUserMessage("📋 Show me all categories");
                    showAllCategoriesOverview(container);

                } else if (value === 'explain_impact_levels') {
                    addUserMessage("🤔 Explain impact levels");
                    showImpactLevelExplanation(container);

                } else if (value === 'auto_select_best') {
                    addUserMessage("⚡ Auto-select the best items");
                    autoSelectBestItems(container);

                } else if (value === 'back_to_overview') {
                    addUserMessage("🔄 Back to overview");
                    showDisputeOverview(container);

                } else if (value.startsWith('show_impact_')) {
                    const impactLevel = value.replace('show_impact_', '');
                    addUserMessage(`Show ${impactLevel.replace('_', ' ')} items`);
                    showImpactCategory(impactLevel, container);

                } else if (value.startsWith('review_group_')) {
                    const parts = value.replace('review_group_', '').split('_');
                    const impactLevel = parts[0] + '_' + parts[1]; // high_impact, medium_impact, low_impact
                    const groupType = parts.slice(2).join('_'); // rejoin any underscores in group type
                    const grouped = conversationState.groupedItems;
                    const category = grouped[impactLevel];
                    const group = category.groups.find(g => g.type === groupType);

                    addUserMessage(`Review ${group ? group.displayName : groupType}`);
                    reviewItemGroup(impactLevel, groupType, container);

                } else if (value.startsWith('select_item_')) {
                    const parts = value.replace('select_item_', '').split('_');
                    const itemId = parts[0];
                    const impactLevel = parts[1] + '_' + parts[2];
                    const groupType = parts.slice(3).join('_');

                    selectItemForDispute(itemId, impactLevel, groupType, container);

                } else if (value.startsWith('skip_item_')) {
                    const parts = value.replace('skip_item_', '').split('_');
                    const itemId = parts[0];
                    const impactLevel = parts[1] + '_' + parts[2];
                    const groupType = parts.slice(3).join('_');

                    skipItem(itemId, impactLevel, groupType, container);

                } else if (value.startsWith('explain_item_')) {
                    const parts = value.replace('explain_item_', '').split('_');
                    const itemId = parts[0];
                    const impactLevel = parts[1] + '_' + parts[2];
                    const groupType = parts.slice(3).join('_');

                    explainItem(itemId, impactLevel, groupType, container);

                } else if (value.startsWith('select_all_remaining_')) {
                    const parts = value.replace('select_all_remaining_', '').split('_');
                    const impactLevel = parts[0] + '_' + parts[1];
                    const groupType = parts.slice(2).join('_');

                    selectAllRemainingItems(impactLevel, groupType, container);

                } else if (value === 'show_progress') {
                    addUserMessage("📊 Show my progress");
                    showProgress(container);

                } else if (value === 'continue_review') {
                    addUserMessage("▶️ Continue reviewing");
                    continueReview(container);

                } else if (value === 'generate_letters') {
                    addUserMessage("📄 Generate dispute letters");
                    generateDisputeLetters(container);

                } else if (value === 'download_letters') {
                    addUserMessage("💾 Download my letters as PDF");
                    downloadGeneratedLetters(container);

                } else if (value === 'email_letters') {
                    addUserMessage("📧 Email letters to me");
                    emailGeneratedLetters(container);

                } else if (value === 'show_final_summary') {
                    addUserMessage("📊 Show final summary");
                    showFinalDisputeSummary(container);

                } else if (value === 'restart_analysis') {
                    addUserMessage("🔄 Start new analysis");
                    restartAnalysisProcess(container);

                    // NEW: User information collection handlers
                } else if (value === 'confirm_user_info') {
                    addUserMessage("✅ Information is correct");
                    // Use existing user data and proceed with letter generation
                    const userData = JSON.parse(localStorage.getItem('userData') || '{}');
                    addBotMessage(`📄 Perfect! Generating dispute letters for ${conversationState.selectedItems.length} selected items with your confirmed information...`);
                    showTypingIndicator(container);
                    generateLettersFromBackend(conversationState.selectedItems, container);

                } else if (value === 'update_user_info') {
                    addUserMessage("✏️ I want to update my information");
                    const userData = JSON.parse(localStorage.getItem('userData') || '{}');
                    startUserInfoCollection(userData, container);

                } else if (value === 'confirm_user_info_and_generate') {
                    confirmUserInfoAndGenerate(container);

                } else if (value === 'edit_collected_info') {
                    editCollectedInfo(container);

                } else if (value === 'finish_editing_info') {
                    addUserMessage("✅ Done editing information");
                    showCollectedUserInfoSummary(container);

                } else if (value.startsWith('edit_field_')) {
                    const field = value.replace('edit_field_', '');
                    editSpecificField(field, container);

                } else {
                    // Fallback for unhandled button clicks
                    console.log('Unhandled button click:', value);
                    addBotMessage("I didn't understand that action. Please try again or use the available buttons.");
                    updateMessagesDisplay(container);
                    saveState();
                }

                debugLog('handleButtonClick', 'COMPLETED', { value: value });
            }

            // NEW: Additional conversation flow helper functions
            function showAllCategoriesOverview(container) {
                const grouped = conversationState.groupedItems;
                if (!grouped) return;

                let message = `📋 **All Categories Overview**\n\n`;

                ['high_impact', 'medium_impact', 'low_impact'].forEach(level => {
                    const category = grouped[level];
                    message += `${category.emoji} **${category.level}** (${category.totalItems} items)\n`;
                    message += `${category.description}\n`;

                    if (category.groups.length > 0) {
                        category.groups.slice(0, 3).forEach(group => {
                            message += `  • ${getTypeEmoji(group.type)} ${group.displayName} (${group.items.length})\n`;
                        });
                        if (category.groups.length > 3) {
                            message += `  • ...and ${category.groups.length - 3} more categories\n`;
                        }
                    }
                    message += `\n`;
                });

                const buttons = [
                    { text: `🎯 Start with High Impact (${grouped.high_impact.totalItems})`, value: "start_high_impact" },
                    { text: `📊 Review Medium Impact (${grouped.medium_impact.totalItems})`, value: "show_impact_medium_impact" },
                    { text: `📈 Check Low Impact (${grouped.low_impact.totalItems})`, value: "show_impact_low_impact" },
                    { text: "🔄 Back to Overview", value: "back_to_overview" }
                ];

                addBotMessageWithButtons(message, buttons);
                updateMessagesDisplay(container);
                saveState();
            }

            function autoSelectBestItems(container) {
                if (!conversationState.groupedItems) return;

                // Auto-select high-impact items with high confidence
                const highImpactItems = conversationState.groupedItems.high_impact.items.filter(item =>
                    item.confidence_level === 'high' && item.calculatedImpact >= 75
                );

                conversationState.selectedItems = [...highImpactItems];

                let message = `⚡ **Auto-Selection Complete!**\n\n`;
                message += `I've automatically selected **${highImpactItems.length} high-impact items** with the highest success probability.\n\n`;
                message += `📈 **Potential Score Boost:** +${calculateScoreImpact(highImpactItems.length)} points\n\n`;
                message += `These are your best bets for quick credit score improvement!`;

                const buttons = [
                    { text: "📄 Generate Letters Now", value: "generate_letters" },
                    { text: "➕ Add More Items", value: "continue_review" },
                    { text: "📊 Review Selections", value: "show_progress" },
                    { text: "🔄 Start Over", value: "back_to_overview" }
                ];

                addBotMessageWithButtons(message, buttons);
                updateMessagesDisplay(container);
                saveState();
            }

            function selectItemForDispute(itemId, impactLevel, groupType, container) {
                const grouped = conversationState.groupedItems;
                const category = grouped[impactLevel];
                const group = category.groups.find(g => g.type === groupType);

                if (!group) return;

                const item = group.items.find(i => (i.id || group.items.indexOf(i)) == itemId);
                if (!item) return;

                // Add to selected items
                conversationState.selectedItems.push(item);

                addUserMessage("✅ Yes, dispute this item");

                // Continue to next item
                const currentIndex = group.items.indexOf(item);
                const nextIndex = currentIndex + 1;

                if (nextIndex < group.items.length) {
                    setTimeout(() => {
                        showItemForReview(group.items, nextIndex, impactLevel, groupType, container);
                    }, 500);
                } else {
                    // Finished this group
                    setTimeout(() => {
                        showGroupCompletionSummary(impactLevel, groupType, container);
                    }, 500);
                }
            }

            function skipItem(itemId, impactLevel, groupType, container) {
                const grouped = conversationState.groupedItems;
                const category = grouped[impactLevel];
                const group = category.groups.find(g => g.type === groupType);

                if (!group) return;

                const item = group.items.find(i => (i.id || group.items.indexOf(i)) == itemId);
                if (!item) return;

                // Add to skipped items
                conversationState.skippedItems.push(item);

                addUserMessage("⏭️ Skip this item");

                // Continue to next item
                const currentIndex = group.items.indexOf(item);
                const nextIndex = currentIndex + 1;

                setTimeout(() => {
                    showItemForReview(group.items, nextIndex, impactLevel, groupType, container);
                }, 500);
            }

            function explainItem(itemId, impactLevel, groupType, container) {
                const grouped = conversationState.groupedItems;
                const category = grouped[impactLevel];
                const group = category.groups.find(g => g.type === groupType);

                if (!group) return;

                const item = group.items.find(i => (i.id || group.items.indexOf(i)) == itemId);
                if (!item) return;

                addUserMessage("❓ Tell me more about this item");

                let explanation = `🔍 **Detailed Analysis**\n\n`;
                explanation += `**Why this item appeared:**\n`;
                explanation += `${item.issue_details || item.dispute_reason || 'This item was flagged as potentially inaccurate'}\n\n`;

                explanation += `**How disputes work for ${getTypeEmoji(groupType)} ${formatCategoryName(groupType)}:**\n`;
                explanation += `${getDisputeStrategy(groupType)}\n\n`;

                explanation += `**What happens next:**\n`;
                explanation += `1. We generate a professional dispute letter\n`;
                explanation += `2. You mail it to the credit bureaus\n`;
                explanation += `3. They have 30 days to investigate\n`;
                explanation += `4. If they can't verify, they must remove it\n\n`;

                explanation += `**Success rate:** ${getSuccessRate(groupType)} of similar disputes succeed`;

                const buttons = [
                    { text: "✅ Sounds good, dispute it", value: `select_item_${itemId}_${impactLevel}_${groupType}` },
                    { text: "⏭️ Skip this one", value: `skip_item_${itemId}_${impactLevel}_${groupType}` },
                    { text: "🔄 Back to item", value: `back_to_item_${itemId}_${impactLevel}_${groupType}` }
                ];

                addBotMessageWithButtons(explanation, buttons);
                updateMessagesDisplay(container);
                saveState();
            }

            function selectAllRemainingItems(impactLevel, groupType, container) {
                const grouped = conversationState.groupedItems;
                const category = grouped[impactLevel];
                const group = category.groups.find(g => g.type === groupType);

                if (!group) return;

                // Find items not yet selected or skipped
                const remainingItems = group.items.filter(item =>
                    !conversationState.selectedItems.includes(item) &&
                    !conversationState.skippedItems.includes(item)
                );

                // Add all remaining to selected
                conversationState.selectedItems.push(...remainingItems);

                addUserMessage(`⏯️ Select all remaining ${remainingItems.length} items`);

                setTimeout(() => {
                    showGroupCompletionSummary(impactLevel, groupType, container);
                }, 500);
            }

            function continueReview(container) {
                // Find next unreviewed category/group
                const grouped = conversationState.groupedItems;

                for (const level of conversationState.categoryOrder) {
                    const category = grouped[level];
                    for (const group of category.groups) {
                        const hasUnreviewedItems = group.items.some(item =>
                            !conversationState.selectedItems.includes(item) &&
                            !conversationState.skippedItems.includes(item)
                        );

                        if (hasUnreviewedItems) {
                            reviewItemGroup(level, group.type, container);
                            return;
                        }
                    }
                }

                // All items reviewed
                addBotMessage("🎉 You've reviewed all items! Great work!");
                showProgress(container);
            }

            function generateDisputeLetters(container) {
                if (conversationState.selectedItems.length === 0) {
                    addBotMessage("You haven't selected any items to dispute yet. Please review and select items first.");
                    updateMessagesDisplay(container);
                    return;
                }

                // NEW: Check if we have complete user information before generating letters
                checkAndCollectUserInfo(container);
            }

            // NEW: Function to check and collect user information
            function checkAndCollectUserInfo(container) {
                // Get existing user data
                const userData = JSON.parse(localStorage.getItem('userData') || '{}');

                // Check what information we have
                const hasName = userData.name || (userData.firstName && userData.lastName);
                const hasAddress = userData.address && userData.city && userData.state && userData.zipCode;
                const hasEmail = userData.email || userData.userEmail;
                const hasPhone = userData.phone || userData.phoneNumber;

                console.log('Current user data check:', {
                    hasName,
                    hasAddress,
                    hasEmail,
                    hasPhone,
                    userData: userData
                });

                if (hasName && hasAddress && hasEmail && hasPhone) {
                    // We have all required information, show confirmation
                    showUserInfoConfirmation(userData, container);
                } else {
                    // Missing information, collect it
                    startUserInfoCollection(userData, container);
                }
            }

            // NEW: Show confirmation of existing user information
            function showUserInfoConfirmation(userData, container) {
                const fullName = userData.name || `${userData.firstName || ''} ${userData.lastName || ''}`.trim();
                const fullAddress = `${userData.address || ''}, ${userData.city || ''}, ${userData.state || ''} ${userData.zipCode || ''}`;
                const email = userData.email || userData.userEmail || '';
                const phone = userData.phone || userData.phoneNumber || '';

                let message = `📋 **Confirm Your Information**\n\n`;
                message += `Before generating your dispute letters, please confirm your information:\n\n`;
                message += `👤 **Name:** ${fullName}\n`;
                message += `🏠 **Address:** ${fullAddress}\n`;
                message += `📧 **Email:** ${email}\n`;
                message += `📞 **Phone:** ${phone}\n\n`;
                message += `💡 This information will be used in your professional dispute letters.`;

                const buttons = [
                    { text: "✅ Information is Correct", value: "confirm_user_info" },
                    { text: "✏️ Update My Information", value: "update_user_info" },
                    { text: "🔙 Back to Selection", value: "show_progress" }
                ];

                addBotMessageWithButtons(message, buttons);
                updateMessagesDisplay(container);
                saveState();
            }

            // NEW: Start collecting missing user information
            function startUserInfoCollection(existingData, container) {
                // Store what we need to collect
                conversationState.userInfoCollection = {
                    step: 'name',
                    collectedData: { ...existingData },
                    requiredFields: ['name', 'address', 'city', 'state', 'zipCode', 'email', 'phone']
                };

                let message = `📝 **Personal Information Required**\n\n`;
                message += `To generate professional dispute letters, I need to collect some personal information.\n\n`;
                message += `🔒 **Privacy Note:** This information is only used for your dispute letters and stored securely.\n\n`;
                message += `Let's start with your full legal name:`;

                // Create input form for name
                showUserInfoInputForm('name', 'Your Full Legal Name', existingData.name || `${existingData.firstName || ''} ${existingData.lastName || ''}`.trim(), container);
            }

            // NEW: Show input form for collecting user information
            function showUserInfoInputForm(field, label, currentValue, container) {
                const fieldDescriptions = {
                    'name': 'Enter your full legal name as it should appear on the dispute letters',
                    'address': 'Enter your street address (e.g., 123 Main Street)',
                    'city': 'Enter your city',
                    'state': 'Enter your state (e.g., CA, NY, TX)',
                    'zipCode': 'Enter your ZIP code',
                    'email': 'Enter your email address',
                    'phone': 'Enter your phone number (e.g., (555) 123-4567)'
                };

                let message = `📝 **${label}**\n\n`;
                message += `${fieldDescriptions[field]}\n\n`;

                if (currentValue) {
                    message += `Current value: "${currentValue}"\n\n`;
                }

                // Add custom input interface
                addBotMessage(message);

                // Create a custom input form
                const messagesContainer = container.querySelector('.Bot-chat-messages');
                const inputFormElement = document.createElement('div');
                inputFormElement.className = 'Bot-message bot user-info-form';
                inputFormElement.innerHTML = `
                    <div class="Bot-message-avatar">🤖</div>
                    <div class="Bot-message-content">
                        <div style="margin-bottom: 15px;">
                            <input type="text" 
                                   id="userInfoInput" 
                                   placeholder="${label}" 
                                   value="${currentValue || ''}"
                                   style="width: 100%; padding: 10px; border: 1px solid #ddd; border-radius: 8px; font-size: 14px;"
                                   onkeydown="if(event.key==='Enter') ChatModule.handleUserInfoSubmit('${field}', this.value, this.closest('.Bot-chat-container'))">
                        </div>
                        <div style="display: flex; gap: 10px;">
                            <button onclick="ChatModule.handleUserInfoSubmit('${field}', document.getElementById('userInfoInput').value, this.closest('.Bot-chat-container'))" 
                                    style="background: #09ccfc; color: white; border: none; padding: 8px 16px; border-radius: 20px; cursor: pointer;">
                                Continue ✓
                            </button>
                            ${currentValue ? `<button onclick="ChatModule.handleUserInfoSubmit('${field}', '${currentValue}', this.closest('.Bot-chat-container'))" 
                                              style="background: #6c757d; color: white; border: none; padding: 8px 16px; border-radius: 20px; cursor: pointer;">
                                Keep Current
                            </button>` : ''}
                        </div>
                    </div>
                `;

                messagesContainer.appendChild(inputFormElement);
                messagesContainer.scrollTop = messagesContainer.scrollHeight;

                // Focus the input
                setTimeout(() => {
                    const input = document.getElementById('userInfoInput');
                    if (input) input.focus();
                }, 100);
            }

            // NEW: Handle user info form submission
            function handleUserInfoSubmit(field, value, container) {
                if (!value || value.trim() === '') {
                    addBotMessage("Please enter a value to continue.");
                    updateMessagesDisplay(container);
                    return;
                }

                // Remove the input form
                const inputForm = container.querySelector('.user-info-form');
                if (inputForm) {
                    inputForm.remove();
                }

                // Store the collected value
                if (!conversationState.userInfoCollection) {
                    conversationState.userInfoCollection = {
                        step: field,
                        collectedData: {},
                        requiredFields: ['name', 'address', 'city', 'state', 'zipCode', 'email', 'phone']
                    };
                }

                conversationState.userInfoCollection.collectedData[field] = value.trim();

                // Show what was entered
                addUserMessage(`${field}: ${value.trim()}`);
                addBotMessage(`✅ Got it! ${field === 'name' ? 'Name' : field === 'address' ? 'Address' : field === 'city' ? 'City' : field === 'state' ? 'State' : field === 'zipCode' ? 'ZIP Code' : field === 'email' ? 'Email' : 'Phone'}: ${value.trim()}`);

                // Move to next field
                proceedToNextUserInfoField(container);
            }

            // NEW: Proceed to next field in user info collection
            function proceedToNextUserInfoField(container) {
                const { collectedData, requiredFields } = conversationState.userInfoCollection;

                // Find next missing field
                let nextField = null;
                for (const field of requiredFields) {
                    if (!collectedData[field] || collectedData[field].trim() === '') {
                        nextField = field;
                        break;
                    }
                }

                if (nextField) {
                    // Continue collecting
                    conversationState.userInfoCollection.step = nextField;

                    const fieldLabels = {
                        'name': 'Your Full Legal Name',
                        'address': 'Street Address',
                        'city': 'City',
                        'state': 'State',
                        'zipCode': 'ZIP Code',
                        'email': 'Email Address',
                        'phone': 'Phone Number'
                    };

                    setTimeout(() => {
                        showUserInfoInputForm(nextField, fieldLabels[nextField], collectedData[nextField] || '', container);
                    }, 1000);
                } else {
                    // All fields collected, show summary
                    showCollectedUserInfoSummary(container);
                }
            }

            // NEW: Show summary of collected user information
            function showCollectedUserInfoSummary(container) {
                const data = conversationState.userInfoCollection.collectedData;

                let message = `📋 **Information Summary**\n\n`;
                message += `Please review the information you provided:\n\n`;
                message += `👤 **Name:** ${data.name}\n`;
                message += `🏠 **Address:** ${data.address}\n`;
                message += `🏙️ **City:** ${data.city}\n`;
                message += `🗺️ **State:** ${data.state}\n`;
                message += `📮 **ZIP Code:** ${data.zipCode}\n`;
                message += `📧 **Email:** ${data.email}\n`;
                message += `📞 **Phone:** ${data.phone}\n\n`;
                message += `Is this information correct?`;

                const buttons = [
                    { text: "✅ Yes, Generate Letters", value: "confirm_user_info_and_generate" },
                    { text: "✏️ Edit Information", value: "edit_collected_info" },
                    { text: "🔙 Back to Selection", value: "show_progress" }
                ];

                addBotMessageWithButtons(message, buttons);
                updateMessagesDisplay(container);
                saveState();
            }

            // NEW: Handle confirmed user information and generate letters
            function confirmUserInfoAndGenerate(container) {
                // Save the collected information to localStorage
                const collectedData = conversationState.userInfoCollection?.collectedData;

                if (collectedData) {
                    const userData = JSON.parse(localStorage.getItem('userData') || '{}');

                    // Update userData with collected information
                    const updatedUserData = {
                        ...userData,
                        name: collectedData.name,
                        address: collectedData.address,
                        city: collectedData.city,
                        state: collectedData.state,
                        zipCode: collectedData.zipCode,
                        email: collectedData.email || userData.email || userData.userEmail,
                        userEmail: collectedData.email || userData.email || userData.userEmail,
                        phone: collectedData.phone
                    };

                    localStorage.setItem('userData', JSON.stringify(updatedUserData));
                    console.log('Updated user data saved:', updatedUserData);
                }

                addUserMessage("✅ Information confirmed, generate my letters");
                addBotMessage(`📄 Perfect! Generating dispute letters for ${conversationState.selectedItems.length} selected items with your confirmed information...`);

                showTypingIndicator(container);

                // Proceed with letter generation
                generateLettersFromBackend(conversationState.selectedItems, container);
            }

            // NEW: Handle editing collected information
            function editCollectedInfo(container) {
                addUserMessage("✏️ Let me edit my information");

                const data = conversationState.userInfoCollection?.collectedData || {};

                let message = `✏️ **Edit Your Information**\n\n`;
                message += `Which field would you like to update?\n\n`;
                message += `👤 **Name:** ${data.name || 'Not set'}\n`;
                message += `🏠 **Address:** ${data.address || 'Not set'}\n`;
                message += `🏙️ **City:** ${data.city || 'Not set'}\n`;
                message += `🗺️ **State:** ${data.state || 'Not set'}\n`;
                message += `📮 **ZIP Code:** ${data.zipCode || 'Not set'}\n`;
                message += `📧 **Email:** ${data.email || 'Not set'}\n`;
                message += `📞 **Phone:** ${data.phone || 'Not set'}`;

                const buttons = [
                    { text: "👤 Edit Name", value: "edit_field_name" },
                    { text: "🏠 Edit Address", value: "edit_field_address" },
                    { text: "🏙️ Edit City", value: "edit_field_city" },
                    { text: "🗺️ Edit State", value: "edit_field_state" },
                    { text: "📮 Edit ZIP", value: "edit_field_zipCode" },
                    { text: "📧 Edit Email", value: "edit_field_email" },
                    { text: "📞 Edit Phone", value: "edit_field_phone" },
                    { text: "✅ Done Editing", value: "finish_editing_info" }
                ];

                addBotMessageWithButtons(message, buttons);
                updateMessagesDisplay(container);
                saveState();
            }

            // NEW: Handle editing a specific field
            function editSpecificField(field, container) {
                const data = conversationState.userInfoCollection?.collectedData || {};
                const currentValue = data[field] || '';

                const fieldLabels = {
                    'name': 'Your Full Legal Name',
                    'address': 'Street Address',
                    'city': 'City',
                    'state': 'State',
                    'zipCode': 'ZIP Code',
                    'email': 'Email Address',
                    'phone': 'Phone Number'
                };

                addUserMessage(`Edit ${fieldLabels[field]}`);
                showUserInfoInputForm(field, fieldLabels[field], currentValue, container);
            }

            // NEW: Function to send letter generation requests to backend
            async function generateLettersFromBackend(selectedItems, container) {
                try {
                    console.log('📄 Sending letter generation request to backend...', {
                        itemCount: selectedItems.length,
                        items: selectedItems.map(item => ({
                            creditor: item.creditor_name,
                            dispute_reason: item.dispute_reason,
                            impact: item.calculatedImpact
                        }))
                    });

                    // Get user data and auth token
                    const userData = JSON.parse(localStorage.getItem('userData') || '{}');
                    const userId = userData.id;
                    const userEmail = userData.email;
                    const authToken = localStorage.getItem('authToken') ||
                        localStorage.getItem('token') ||
                        sessionStorage.getItem('authToken') ||
                        sessionStorage.getItem('token');

                    if (!userId || !userEmail || !authToken) {
                        throw new Error('User authentication required for letter generation');
                    }

                    // Prepare detailed user information for letter generation
                    const detailedUserInfo = {
                        userId: userId,
                        userEmail: userEmail,
                        name: userData.name || userData.firstName + ' ' + userData.lastName || userData.username || 'User',
                        firstName: userData.firstName || userData.name?.split(' ')[0] || 'First',
                        lastName: userData.lastName || userData.name?.split(' ').slice(1).join(' ') || 'Last',
                        address: userData.address || userData.streetAddress || null,
                        city: userData.city || null,
                        state: userData.state || null,
                        zipCode: userData.zipCode || userData.zip || null,
                        phone: userData.phone || userData.phoneNumber || null,
                        email: userEmail
                    };

                    console.log('Detailed user info for letter generation:', detailedUserInfo);

                    // Prepare letter generation request
                    const requestData = {
                        userId: userId,
                        userEmail: userEmail,
                        selectedItems: selectedItems.map(item => ({
                            id: item.id,
                            creditor_name: item.creditor_name,
                            account_number: item.account_number,
                            dispute_reason: item.dispute_reason,
                            bureau: item.bureau,
                            amount: item.amount,
                            analysis_pass: item.analysis_pass,
                            confidence_level: item.confidence_level,
                            calculatedImpact: item.calculatedImpact,
                            issue_details: item.issue_details
                        })),
                        analysisData: currentAnalysisData,
                        conversationState: {
                            selectedCount: conversationState.selectedItems.length,
                            categories: conversationState.completedCategories,
                            userChoices: conversationState.userChoices
                        }
                    };

                    // Send request to backend for ChatGPT letter generation
                    const response = await fetch('http://localhost:3000/api/chat/generate-letters', {
                        method: 'POST',
                        headers: {
                            'Authorization': `Bearer ${authToken}`,
                            'Content-Type': 'application/json'
                        },
                        body: JSON.stringify({
                            items: selectedItems.map(item => ({
                                id: item.id,
                                creditor_name: item.creditor_name,
                                account_number: item.account_number,
                                dispute_reason: item.dispute_reason,
                                bureau: item.bureau,
                                amount: item.amount,
                                analysis_pass: item.analysis_pass,
                                confidence_level: item.confidence_level,
                                calculatedImpact: item.calculatedImpact,
                                issue_details: item.issue_details
                            })),
                            userInfo: detailedUserInfo,
                            analysisData: currentAnalysisData,
                            conversationState: {
                                selectedCount: conversationState.selectedItems.length,
                                categories: conversationState.completedCategories,
                                userChoices: conversationState.userChoices
                            }
                        })
                    });

                    if (!response.ok) {
                        const errorText = await response.text();
                        throw new Error(`Letter generation failed: ${response.status} - ${errorText}`);
                    }

                    const result = await response.json();

                    hideTypingIndicator(container);

                    if (result.success) {
                        console.log('✅ Letters generated successfully:', {
                            letterCount: result.letters?.length || 0,
                            hasLetters: !!result.letters,
                            bureaus: result.summary?.bureaus || []
                        });

                        // Show success message with actual letter count
                        let summary = `✅ **Letter Generation Complete!**\n\n`;
                        summary += `📋 **Generated Letters:** ${result.summary?.successfulLetters || selectedItems.length}\n`;
                        if (result.summary?.bureaus) {
                            summary += `📊 **Bureaus:** ${result.summary.bureaus.join(', ')}\n`;
                        }
                        summary += `📈 **Potential Score Boost:** +${calculateScoreImpact(selectedItems.length)} points\n\n`;
                        summary += `Your personalized dispute letters have been generated by our AI system! Each letter is customized with:\n`;
                        summary += `• Specific dispute reasons for each item\n`;
                        summary += `• Professional legal language\n`;
                        summary += `• Bureau-specific formatting\n`;
                        summary += `• Your personal information\n\n`;
                        summary += `💡 **Next Steps:** Review and send your letters to the credit bureaus.`;

                        addBotMessageWithButtons(summary, [
                            { text: "📄 View My Letters", value: "view_letters" },
                            { text: "📊 Final Summary", value: "show_final_summary" },
                            { text: "💾 Download PDF Letters", value: "download_letters" },
                            { text: "📧 Email Letters to Me", value: "email_letters" }
                        ]);

                        // Store generated letters data
                        localStorage.setItem('jamBotGeneratedLetters', JSON.stringify(result.letters || []));
                        localStorage.setItem('jamBotLastLetterGeneration', JSON.stringify({
                            timestamp: new Date().toISOString(),
                            selectedItemsCount: selectedItems.length,
                            letterCount: result.letters?.length || 0,
                            bureaus: result.summary?.bureaus || [],
                            success: true
                        }));

                    } else {
                        throw new Error(result.error || 'Unknown error during letter generation');
                    }

                } catch (error) {
                    console.error('❌ Letter generation error:', error);

                    hideTypingIndicator(container);

                    let errorMessage = "I encountered an error while generating your dispute letters. ";

                    if (error.message.includes('authentication')) {
                        errorMessage += "Please refresh the page and try again.";
                    } else if (error.message.includes('500')) {
                        errorMessage += "There was a server error. Please try again in a few moments.";
                    } else {
                        errorMessage += "Please try again or contact support if the problem persists.";
                    }

                    addBotMessageWithButtons(errorMessage, [
                        { text: "🔄 Try Again", value: "generate_letters" },
                        { text: "📊 Show Progress", value: "show_progress" },
                        { text: "🏠 Back to Overview", value: "back_to_overview" }
                    ]);
                }

                updateMessagesDisplay(container);
                saveState();
            }

            // NEW: Helper functions for letter generation actions
            async function downloadGeneratedLetters(container) {
                try {
                    const savedLetters = localStorage.getItem('jamBotGeneratedLetters');
                    if (!savedLetters) {
                        addBotMessage("No letters found. Please generate letters first.");
                        updateMessagesDisplay(container);
                        return;
                    }

                    const letters = JSON.parse(savedLetters);

                    addBotMessage("📄 Preparing your dispute letters as PDF files...");
                    showTypingIndicator(container);

                    // Send request to backend to generate PDFs
                    const userData = JSON.parse(localStorage.getItem('userData') || '{}');
                    const authToken = localStorage.getItem('authToken') || localStorage.getItem('token');

                    const response = await fetch('http://localhost:3000/api/chat/download-letters', {
                        method: 'POST',
                        headers: {
                            'Authorization': `Bearer ${authToken}`,
                            'Content-Type': 'application/json'
                        },
                        body: JSON.stringify({
                            userId: userData.id,
                            letters: letters
                        })
                    });

                    hideTypingIndicator(container);

                    if (response.ok) {
                        const result = await response.json();

                        if (result.letterType === 'single_pdf') {
                            // Single PDF download
                            downloadPDFFromContent(result.pdfContent, result.filename);
                            addBotMessage(`✅ Your dispute letter has been downloaded as a PDF file: "${result.filename}"! 

📄 This professional dispute letter is ready to mail to ${result.bureau.charAt(0).toUpperCase() + result.bureau.slice(1)} Credit Bureau.

💡 **Next Steps:**
1. Print the PDF on letterhead (if available)
2. Sign the letter by hand
3. Mail via certified mail with return receipt
4. Keep copies for your records`);
                        } else if (result.letterType === 'multiple_pdfs') {
                            // Multiple PDFs - download each one
                            let downloadCount = 0;
                            result.letters.forEach((letter, index) => {
                                setTimeout(() => {
                                    downloadPDFFromContent(letter.pdfContent, letter.filename);
                                    downloadCount++;

                                    if (downloadCount === result.letters.length) {
                                        addBotMessage(`✅ All ${result.letters.length} dispute letters have been downloaded as separate PDF files!

📄 **Downloaded Letters:**
${result.letters.map(l => `• ${l.filename} (${l.bureau.charAt(0).toUpperCase() + l.bureau.slice(1)} - ${l.itemCount} items)`).join('\n')}

💡 **Next Steps:**
1. Print each PDF on letterhead (if available)
2. Sign each letter by hand  
3. Mail to respective credit bureaus via certified mail
4. Keep copies for your records

🎯 **Pro Tip:** Send all letters on the same day for maximum impact!`);
                                        updateMessagesDisplay(container);
                                    }
                                }, index * 1000); // Stagger downloads by 1 second
                            });

                            if (result.letters.length > 1) {
                                addBotMessage(`📥 Downloading ${result.letters.length} PDF files (one for each bureau: ${result.downloadInfo.bureaus.join(', ')})...`);
                            }
                        }
                    } else {
                        throw new Error('Download failed');
                    }

                } catch (error) {
                    hideTypingIndicator(container);
                    addBotMessage("❌ Sorry, I couldn't download your letters. Please try again or contact support.");
                }

                updateMessagesDisplay(container);
            }

            // NEW: Helper function to convert PDF content to downloadable file
            function downloadPDFFromContent(pdfContent, filename) {
                try {
                    // Check if jsPDF is available
                    if (typeof window.jsPDF === 'undefined') {
                        console.error('jsPDF not available - cannot generate PDF');
                        throw new Error('PDF generation library not available');
                    }

                    // Create new PDF document
                    const { jsPDF } = window.jsPDF;
                    const doc = new jsPDF('p', 'pt', 'letter');

                    // Set up fonts and styling
                    doc.setFont('helvetica');

                    // Add header
                    doc.setFontSize(16);
                    doc.setFont('helvetica', 'bold');
                    doc.text(pdfContent.title, 72, 100);

                    // Add date
                    doc.setFontSize(12);
                    doc.setFont('helvetica', 'normal');
                    doc.text(`Date: ${pdfContent.date}`, 450, 100);

                    // Add horizontal line
                    doc.setLineWidth(1);
                    doc.line(72, 120, 540, 120);

                    // Add main content with proper text wrapping
                    doc.setFontSize(12);
                    const contentLines = doc.splitTextToSize(pdfContent.content, 468); // 540-72 = 468pt width
                    doc.text(contentLines, 72, 150);

                    // Calculate position for footer
                    const contentHeight = contentLines.length * 14; // Approximate line height
                    const footerY = Math.max(150 + contentHeight + 50, 650); // Minimum footer position

                    // Add footer line
                    doc.setLineWidth(0.5);
                    doc.line(72, footerY, 540, footerY);

                    // Add footer text
                    doc.setFontSize(10);
                    doc.setFont('helvetica', 'italic');
                    doc.text(pdfContent.footer, 72, footerY + 20);
                    doc.text(`Generated on: ${new Date().toLocaleString()}`, 72, footerY + 35);

                    // Download the PDF
                    doc.save(filename);

                    console.log(`📄 Downloaded PDF: ${filename}`);
                } catch (error) {
                    console.error('Error generating PDF:', error);
                    addBotMessage("❌ Error generating PDF. Please try again or contact support for assistance.");
                }
            }

            async function emailGeneratedLetters(container) {
                try {
                    const savedLetters = localStorage.getItem('jamBotGeneratedLetters');
                    if (!savedLetters) {
                        addBotMessage("No letters found. Please generate letters first.");
                        updateMessagesDisplay(container);
                        return;
                    }

                    const letters = JSON.parse(savedLetters);
                    const userData = JSON.parse(localStorage.getItem('userData') || '{}');

                    addBotMessage(`📧 Emailing your dispute letters to ${userData.email}...`);
                    showTypingIndicator(container);

                    const authToken = localStorage.getItem('authToken') || localStorage.getItem('token');

                    const response = await fetch('http://localhost:3000/api/chat/email-letters', {
                        method: 'POST',
                        headers: {
                            'Authorization': `Bearer ${authToken}`,
                            'Content-Type': 'application/json'
                        },
                        body: JSON.stringify({
                            userId: userData.id,
                            userEmail: userData.email,
                            letters: letters
                        })
                    });

                    hideTypingIndicator(container);

                    if (response.ok) {
                        addBotMessage(`✅ Your dispute letters have been emailed to ${userData.email}! Please check your inbox (and spam folder).`);
                    } else {
                        throw new Error('Email failed');
                    }

                } catch (error) {
                    hideTypingIndicator(container);
                    addBotMessage("❌ Sorry, I couldn't email your letters. Please try the download option or contact support.");
                }

                updateMessagesDisplay(container);
            }

            function showFinalDisputeSummary(container) {
                const selectedCount = conversationState.selectedItems.length;
                const totalCount = currentAnalysisData?.extractedItems?.length || 0;
                const scoreImpact = calculateScoreImpact(selectedCount);
                const grouped = conversationState.groupedItems;

                let summary = `🎉 **Dispute Process Complete!**\n\n`;
                summary += `📊 **Your Results:**\n`;
                summary += `• **Total Items Found:** ${totalCount}\n`;
                summary += `• **Selected for Dispute:** ${selectedCount}\n`;
                summary += `• **Success Rate:** 60-75% average\n`;
                summary += `• **Potential Score Boost:** +${scoreImpact} points\n\n`;

                if (grouped) {
                    summary += `**Category Breakdown:**\n`;
                    ['high_impact', 'medium_impact', 'low_impact'].forEach(level => {
                        const category = grouped[level];
                        const selectedFromCategory = conversationState.selectedItems.filter(item => {
                            const impact = item.calculatedImpact;
                            return level === 'high_impact' ? impact >= 65 :
                                level === 'medium_impact' ? (impact >= 35 && impact < 65) :
                                    impact < 35;
                        });
                        summary += `• ${category.emoji} ${category.level}: ${selectedFromCategory.length}/${category.totalItems}\n`;
                    });
                }

                summary += `\n💡 **Next Steps:**\n`;
                summary += `1. Review your generated letters\n`;
                summary += `2. Print and mail to credit bureaus\n`;
                summary += `3. Keep copies for your records\n`;
                summary += `4. Follow up in 30-45 days\n\n`;
                summary += `🎯 **Great job taking control of your credit!**`;

                addBotMessageWithButtons(summary, [
                    { text: "📄 View Letters", value: "view_letters" },
                    { text: "💾 Download PDF Letters", value: "download_letters" },
                    { text: "🔄 Start New Analysis", value: "restart_analysis" }
                ]);

                updateMessagesDisplay(container);
                saveState();
            }

            function restartAnalysisProcess(container) {
                // Clear conversation state
                conversationState = {
                    phase: 'overview',
                    currentCategory: null,
                    currentItemIndex: 0,
                    selectedItems: [],
                    skippedItems: [],
                    completedCategories: [],
                    userChoices: {},
                    groupedItems: null,
                    categoryOrder: ['high_impact', 'medium_impact', 'low_impact']
                };

                // Clear analysis data
                currentAnalysisData = null;
                localStorage.removeItem('jamBotLastAnalysis');
                localStorage.removeItem('jamBotGeneratedLetters');

                addBotMessage("🔄 Starting fresh! Let me analyze your credit reports again to find new opportunities.");

                // Restart the analysis process
                setTimeout(() => {
                    checkForUploadedReports().then(hasReports => {
                        if (hasReports.hasReports) {
                            addBotMessageWithButtons(
                                "Ready to analyze your credit reports for potential dispute items?",
                                [
                                    { text: "Yes, analyze my reports", value: "analyze_reports" },
                                    { text: "Upload new reports first", value: "upload_reports" }
                                ]
                            );
                            updateMessagesDisplay(container);
                        } else {
                            addBotMessage("Please upload your credit reports first so I can analyze them for dispute opportunities.");
                            updateMessagesDisplay(container);
                        }
                    });
                }, 1000);

                updateMessagesDisplay(container);
                saveState();
            }

            // Legacy functions for backward compatibility
            function handleStartDispute(container) {
                if (!currentAnalysisData || !currentAnalysisData.extractedItems) {
                    addBotMessage("I don't have any analysis data. Please analyze your reports first.");
                    return;
                }

                const items = currentAnalysisData.extractedItems;
                if (items.length === 0) {
                    addBotMessage("I didn't find any items to dispute in your credit reports.");
                    return;
                }

                // Use new conversation flow instead
                startDisputeConversationFlow(container);
            }

            function showHighPriorityItems(container) {
                if (!currentAnalysisData || !currentAnalysisData.extractedItems) {
                    addBotMessage("I don't have any analysis data. Please analyze your reports first.");
                    return;
                }

                const items = currentAnalysisData.extractedItems;
                const highPriorityItems = items.filter(item =>
                    item.confidence_level === 'high' ||
                    item.priority === 'high' ||
                    item.dispute_reason?.toLowerCase().includes('error') ||
                    item.dispute_reason?.toLowerCase().includes('inaccurate')
                );

                if (highPriorityItems.length === 0) {
                    addBotMessage("I didn't find any high priority items. Let me show you all items instead.");
                    showAllItems(container);
                    return;
                }

                let message = `Here are the ${highPriorityItems.length} high priority items I found:\n\n`;

                highPriorityItems.forEach((item, index) => {
                    message += `${index + 1}. **${item.creditor_name || 'Unknown Creditor'}**\n`;
                    message += `   Account: ${item.account_number || 'N/A'}\n`;
                    message += `   Issue: ${item.dispute_reason || 'General dispute'}\n`;
                    message += `   Priority: ${item.confidence_level || 'N/A'}\n`;
                    message += `   Bureau: ${item.bureau || 'N/A'}\n\n`;
                });

                addBotMessage(message);

                addBotMessageWithButtons(
                    "Would you like to generate dispute letters for these items?",
                    [
                        { text: "Yes, generate letters", value: "view_letters" },
                        { text: "Show me all items first", value: "show_all_items" },
                        { text: "🎯 Use Smart Dispute Flow", value: "start_dispute" }
                    ]
                );
            }

            function showAllItems(container) {
                if (!currentAnalysisData || !currentAnalysisData.extractedItems) {
                    addBotMessage("I don't have any analysis data. Please analyze your reports first.");
                    return;
                }

                const items = currentAnalysisData.extractedItems;

                if (items.length === 0) {
                    addBotMessage("I didn't find any items to dispute in your credit reports.");
                    return;
                }

                let message = `Here are all ${items.length} items I found:\n\n`;

                items.forEach((item, index) => {
                    message += `${index + 1}. **${item.creditor_name || 'Unknown Creditor'}**\n`;
                    message += `   Account: ${item.account_number || 'N/A'}\n`;
                    message += `   Issue: ${item.dispute_reason || 'General dispute'}\n`;
                    message += `   Priority: ${item.confidence_level || 'N/A'}\n`;
                    message += `   Bureau: ${item.bureau || 'N/A'}\n\n`;
                });

                addBotMessage(message);

                addBotMessageWithButtons(
                    "This is a lot of items! Would you like me to guide you through them strategically?",
                    [
                        { text: "🎯 Yes, guide me through", value: "start_dispute" },
                        { text: "📄 Generate letters for all", value: "view_letters" }
                    ]
                );
            }

            // Initialize the module
            function init(container, parent = null) {
                debugLog('init', 'STARTED');

                if (isInitialized) {
                    debugLog('init', 'ALREADY_INITIALIZED - Checking if interface exists');

                    // Check if the interface actually exists in the container
                    const existingInterface = container.querySelector('.Bot-chat-container');
                    if (existingInterface) {
                        debugLog('init', 'INTERFACE_EXISTS - Updating display');
                        updateMessagesDisplay(container);
                        return true;
                    } else {
                        debugLog('init', 'INTERFACE_MISSING - Re-rendering');
                        // Interface doesn't exist, so we need to render it
                        // Don't return early, continue with initialization
                    }
                }

                try {
                    parentModule = parent;

                    // UPDATED: Always start fresh - clear all chat history when returning
                    console.log('🔄 ChatModule: Starting fresh conversation');
                    messages = [];
                    currentAnalysisData = null;
                    conversationState = {
                        phase: 'overview',
                        currentCategory: null,
                        currentItemIndex: 0,
                        selectedItems: [],
                        skippedItems: [],
                        completedCategories: [],
                        userChoices: {},
                        groupedItems: null,
                        categoryOrder: ['high_impact', 'medium_impact', 'low_impact']
                    };

                    // Stop any active waiting animations from previous sessions
                    stopContinuousWaiting();

                    // Clear any saved chat state
                    localStorage.removeItem('jamBotChatMessages');
                    localStorage.removeItem('jamBotChatState');

                    // Always start with welcome message
                    addBotMessageWithButtons(
                        "👋 **Welcome to JAM Dispute Bot!**\n\nDid you upload your credit reports? Would you like me to check for your credit reports?",
                        [
                            { text: "Yes, check for my reports", value: "check_for_reports" },
                            { text: "No, I haven't uploaded them yet", value: "no_reports_uploaded" }
                        ]
                    );

                    // Always render the interface (even if already initialized)
                    renderChatInterface(container);

                    // Users will now manually check for reports using the button
                    updateMessagesDisplay(container);

                    // Check for uploaded reports and add prompt if needed
                    checkForUploadedReports().then(hasReports => {
                        console.log('🔍 Upload check result:', hasReports);

                        if (hasReports.hasReports && hasReports.count > 0) {
                            console.log(`✅ Found ${hasReports.count} credit reports from ${hasReports.source} - showing analysis prompt`);

                            addBotMessageWithButtons(
                                `I see you've uploaded ${hasReports.count} credit report${hasReports.count > 1 ? 's' : ''}. Would you like me to analyze them for potential items to dispute?`,
                                [
                                    { text: "Yes, analyze my reports", value: "analyze_reports" },
                                    { text: "No, I'll ask something else", value: "skip_analysis" }
                                ]
                            );
                            updateMessagesDisplay(container);
                        } else {
                            console.log(`❌ No credit reports found (source: ${hasReports.source}) - not showing analysis prompt`);
                        }
                    }).catch(error => {
                        console.error('❌ Error checking for reports in init:', error);
                    });

                    updateMessagesDisplay(container);
                    isInitialized = true;

                    debugLog('init', 'SUCCESS - Fresh conversation started');
                    return true;

                } catch (error) {
                    debugLog('init', 'ERROR', { error: error.message });
                    console.error('Error initializing ChatModule:', error);
                    return false;
                }
            }

            // Public API
            return {
                init: init,

                // Public methods for adding messages
                addBotMessage: function (content, container, buttons = null) {
                    const message = addBotMessage(content, buttons);
                    if (container) {
                        updateMessagesDisplay(container);
                    }
                    // Don't auto-save since we want fresh conversations
                    return message;
                },

                addUserMessage: function (content, container) {
                    const message = addUserMessage(content);
                    if (container) {
                        updateMessagesDisplay(container);
                    }
                    // Don't auto-save since we want fresh conversations
                    return message;
                },

                // Public methods for state management
                setChatMessages: function (savedMessages) {
                    if (Array.isArray(savedMessages)) {
                        messages = savedMessages;
                    }
                },

                updateView: function (container) {
                    if (container) {
                        updateMessagesDisplay(container);
                    }
                },

                onReportUploaded: function (container) {
                    console.log('🔄 ChatModule: onReportUploaded called - checking for new reports');

                    checkForUploadedReports().then(hasReports => {
                        console.log('📊 Upload check result in onReportUploaded:', hasReports);

                        if (hasReports.hasReports && hasReports.count > 0) {
                            // Check if we already have this message in the conversation
                            const hasReportMessage = messages.some(msg =>
                                msg.type === 'bot' &&
                                (msg.content.includes("I see you've uploaded your credit report") ||
                                    msg.content.includes("I see you've uploaded") && msg.content.includes("credit report"))
                            );

                            if (!hasReportMessage) {
                                console.log(`✅ New reports detected (${hasReports.count} reports) - adding analysis prompt`);

                                addBotMessageWithButtons(
                                    `Great! I see you've uploaded ${hasReports.count} credit report${hasReports.count > 1 ? 's' : ''}. Would you like me to analyze them for potential items to dispute?`,
                                    [
                                        { text: "Yes, analyze my reports", value: "analyze_reports" },
                                        { text: "No, I'll ask something else", value: "skip_analysis" }
                                    ]
                                );

                                if (container) {
                                    updateMessagesDisplay(container);
                                }
                            } else {
                                console.log('ℹ️ Analysis prompt already shown - not adding duplicate message');
                            }
                        } else {
                            console.log(`❌ No credit reports found after upload event (source: ${hasReports.source})`);
                        }
                    }).catch(error => {
                        console.error('❌ Error checking for reports in onReportUploaded:', error);
                    });
                },

                clearChatHistory: function () {
                    messages = [];
                    currentAnalysisData = null;
                    conversationState = {
                        phase: 'overview',
                        currentCategory: null,
                        currentItemIndex: 0,
                        selectedItems: [],
                        skippedItems: [],
                        completedCategories: [],
                        userChoices: {},
                        groupedItems: null,
                        categoryOrder: ['high_impact', 'medium_impact', 'low_impact']
                    };

                    // Stop any active waiting animations
                    stopContinuousWaiting();

                    localStorage.removeItem('jamBotChatMessages');
                    localStorage.removeItem('jamBotChatState');
                    console.log('✅ Chat history cleared - fresh conversation ready');
                },

                // NEW: Method to manually restart conversation
                restartConversation: function (container) {
                    this.clearChatHistory();
                    if (container) {
                        addBotMessageWithButtons(
                            "👋 **Welcome to JAM Dispute Bot!**\n\nDid you upload your credit reports? Would you like me to check for your credit reports?",
                            [
                                { text: "Yes, check for my reports", value: "check_for_reports" },
                                { text: "No, I haven't uploaded them yet", value: "no_reports_uploaded" }
                            ]
                        );
                        updateMessagesDisplay(container);

                        // Check for uploaded reports
                        checkForUploadedReports().then(hasReports => {
                            console.log('🔄 Restart conversation - upload check:', hasReports);

                            if (hasReports.hasReports && hasReports.count > 0) {
                                console.log(`✅ Found ${hasReports.count} reports in restart - showing analysis prompt`);

                                addBotMessageWithButtons(
                                    `I see you've uploaded ${hasReports.count} credit report${hasReports.count > 1 ? 's' : ''}. Would you like me to analyze them for potential items to dispute?`,
                                    [
                                        { text: "Yes, analyze my reports", value: "analyze_reports" },
                                        { text: "No, I'll ask something else", value: "skip_analysis" }
                                    ]
                                );
                                updateMessagesDisplay(container);
                            } else {
                                console.log(`❌ No reports found in restart (source: ${hasReports.source})`);
                            }
                        }).catch(error => {
                            console.error('❌ Error checking for reports in restart:', error);
                        });
                    }
                },

                getChatState: function () {
                    return messages;
                },

                getCurrentAnalysisData: function () {
                    return currentAnalysisData;
                },

                // Expose handleButtonClick for onclick handlers
                handleButtonClick: handleButtonClick,

                // NEW: Expose handleUserInfoSubmit for user info collection
                handleUserInfoSubmit: handleUserInfoSubmit,

                // Utility methods for debugging
                debugLocalStorage: function () {
                    console.log('=== CHAT MODULE DEBUG ===');
                    console.log('Messages:', messages);
                    console.log('Current Analysis Data:', currentAnalysisData);
                    console.log('Is Initialized:', isInitialized);
                    console.log('Parent Module:', parentModule);
                }
            };
        })();

        // Make ChatModule globally available
        window.ChatModule = ChatModule;
    </script>
</body>

</html>